"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Statcord = void 0;
const tslib_1 = require("tslib");
const fetch_1 = require("@sapphire/fetch");
const framework_1 = require("@sapphire/framework");
const os_1 = require("os");
const systeminformation_1 = require("systeminformation");
const events_1 = tslib_1.__importDefault(require("events"));
const types_1 = require("./types");
/**
 * The Statcord class.
 * @since 1.0.0
 */
class Statcord extends events_1.default {
    constructor(options) {
        super();
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: options
        });
        Object.defineProperty(this, "activeUsers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "popularCommands", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "commandsRun", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "defaultHeader", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: { 'content-type': 'application/json', authorization: this.options?.key ?? '' }
        });
        Object.defineProperty(this, "bandwidthUsage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: '0'
        });
        Object.defineProperty(this, "baseUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.options?.baseUrl ?? 'https://api.statcord.com/v3'
        });
        if (!this.options?.key) {
            throw new Error('[Statcord-Plugin]: Statistics will not be sent because no API key has been provided in the Statcord options.');
        }
    }
    /**
     * Post the statistics collected from the client to Statcord.
     * @since 1.0.0
     */
    async postStats() {
        try {
            const request = await (0, fetch_1.fetch)(`${this.baseUrl}/stats`, {
                method: fetch_1.FetchMethods.Post,
                headers: this.defaultHeader,
                body: {
                    id: this.options?.client_id ?? framework_1.container.client.user?.id,
                    key: this.options?.key,
                    servers: await this.computeTotalGuilds(),
                    users: await this.computeMembersGuilds(),
                    active: this.activeUsers,
                    commands: this.commandsRun.toString(),
                    popular: this.getPopularCommands(),
                    memactive: process.memoryUsage().heapUsed.toString(),
                    memload: Math.round((process.memoryUsage().heapUsed / (0, os_1.totalmem)()) * 100).toString(),
                    cpuload: Math.round((await (0, systeminformation_1.currentLoad)()).currentLoad).toString(),
                    bandwidth: this.bandwidthUsage
                }
            }, fetch_1.FetchResultTypes.JSON);
            if (this.options?.debug) {
                framework_1.container.logger.debug(`[Statcord-Plugin]: Statistics sent correctly > Commands executed: ${this.commandsRun.toLocaleString()} | Active users: ${this.activeUsers.length.toLocaleString()}`);
            }
            this.commandsRun = 0;
            this.popularCommands = [];
            this.activeUsers = [];
            this.bandwidthUsage = '0';
            if (this.options?.debug) {
                framework_1.container.logger.debug('[Statcord-Plugin]: Resetting of temporary statistics for the new statistics collection');
            }
            this.emit(types_1.StatcordEvents.POST_STATS, request);
            return request;
        }
        catch (err) {
            if (err instanceof fetch_1.QueryError) {
                const responseCloned = err.response.clone();
                const responseParsed = await responseCloned
                    .json()
                    .catch(async () => responseCloned.text())
                    .catch(() => 'Unknow error');
                this.emit(types_1.StatcordEvents.POST_STATS_ERROR, responseParsed);
            }
            else {
                this.emit(types_1.StatcordEvents.POST_STATS_ERROR, err);
            }
            return null;
        }
    }
    /**
     * Get current client statistics in Statcord.
     * @since 1.0.0
     */
    async clientStats() {
        try {
            return await (0, fetch_1.fetch)(`${this.baseUrl}/${this.getClientId()}`, { method: fetch_1.FetchMethods.Get, headers: this.defaultHeader }, fetch_1.FetchResultTypes.JSON);
        }
        catch (_) {
            return null;
        }
    }
    /**
     * Check everyone who has voted for the bot today.
     * @param days How many days back votes should be fetched for.
     * @since 1.0.0
     */
    async bucketStats(days = 'all') {
        try {
            return await (0, fetch_1.fetch)(`${this.baseUrl}/${this.getClientId()}/aggregate?days=${days}`, { method: fetch_1.FetchMethods.Get, headers: this.defaultHeader }, fetch_1.FetchResultTypes.JSON);
        }
        catch (_) {
            return null;
        }
    }
    /**
     * Check if someone has voted for the bot today.
     * @param userId The ID of the user you are checking for.
     * @param days How many days back votes should be fetched for.
     * @since 1.0.0
     */
    async userVotesStats(userId, days = 1) {
        try {
            return await (0, fetch_1.fetch)(`${this.baseUrl}/${this.getClientId()}/votes/${userId}?days=${days}`, { method: fetch_1.FetchMethods.Get, headers: this.defaultHeader }, fetch_1.FetchResultTypes.JSON);
        }
        catch (_) {
            return null;
        }
    }
    /**
     * Set the current bot network usage. It is reset at each statistics post.
     * @param usage Bandwidth usage.
     * @since 1.0.0
     */
    setBandwidthUsage(usage) {
        this.bandwidthUsage = usage;
    }
    postCommand(commandId, author) {
        this.commandsRun++;
        if (!this.activeUsers.includes(author))
            this.activeUsers.push(author);
        const commandData = this.popularCommands.find((c) => c.name === commandId);
        if (commandData)
            return commandData.count++;
        this.emit(types_1.StatcordEvents.POST_COMMAND, { id: commandId, author });
        return this.popularCommands.push({ name: commandId, count: 1 });
    }
    async computeMembersGuilds() {
        if (framework_1.container.client.shard && this.options?.sharding) {
            const total = await framework_1.container.client.shard.broadcastEval((c) => c.guilds.cache.reduce((prev, guild) => prev + guild.memberCount, 0));
            return total.reduce((prev, memberCount) => prev + memberCount, 0);
        }
        return framework_1.container.client.guilds.cache.map((g) => g.memberCount).reduce((a, b) => a + b, 0);
    }
    async computeTotalGuilds() {
        if (framework_1.container.client.shard && this.options?.sharding) {
            const total = await framework_1.container.client.shard.broadcastEval((c) => c.guilds.cache.size);
            return total.reduce((prev, memberCount) => prev + memberCount, 0);
        }
        return framework_1.container.client.guilds.cache.size;
    }
    getPopularCommands() {
        return this.popularCommands.sort((a, b) => b.count - a.count).slice(0, 5);
    }
    getClientId() {
        return this.options?.client_id ?? framework_1.container.client.user?.id;
    }
}
exports.Statcord = Statcord;
//# sourceMappingURL=statcord.js.map