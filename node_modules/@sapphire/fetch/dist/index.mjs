import crossFetch from "cross-fetch";
globalThis && globalThis.fetch ? globalThis.fetch : globalThis.fetch = crossFetch;
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// src/lib/QueryError.ts
var _json;
var QueryError = class extends Error {
  constructor(url, code, response, body) {
    super(`Failed to request '${url}' with code ${code}.`);
    __publicField(this, "url");
    __publicField(this, "code");
    __publicField(this, "body");
    __publicField(this, "response");
    __privateAdd(this, _json, void 0);
    this.url = url;
    this.code = code;
    this.body = body;
    this.response = response;
    __privateSet(this, _json, null);
  }
  toJSON() {
    return __privateGet(this, _json) ?? __privateSet(this, _json, JSON.parse(this.body));
  }
};
__name(QueryError, "QueryError");
_json = new WeakMap();

// src/lib/types.ts
var FetchResultTypes = /* @__PURE__ */ ((FetchResultTypes2) => {
  FetchResultTypes2["JSON"] = "json";
  FetchResultTypes2["Buffer"] = "buffer";
  FetchResultTypes2["Blob"] = "blob";
  FetchResultTypes2["Text"] = "text";
  FetchResultTypes2["Result"] = "result";
  return FetchResultTypes2;
})(FetchResultTypes || {});
var FetchMethods = /* @__PURE__ */ ((FetchMethods2) => {
  FetchMethods2["Get"] = "GET";
  FetchMethods2["Head"] = "HEAD";
  FetchMethods2["Post"] = "POST";
  FetchMethods2["Put"] = "PUT";
  FetchMethods2["Delete"] = "DELETE";
  FetchMethods2["Connect"] = "CONNECT";
  FetchMethods2["Options"] = "OPTIONS";
  FetchMethods2["Trace"] = "TRACE";
  FetchMethods2["Patch"] = "PATCH";
  return FetchMethods2;
})(FetchMethods || {});
var FetchMediaContentTypes = /* @__PURE__ */ ((FetchMediaContentTypes2) => {
  FetchMediaContentTypes2["AudioAac"] = "audio/aac";
  FetchMediaContentTypes2["AudioMp4"] = "audio/mp4";
  FetchMediaContentTypes2["AudioMpeg"] = "audio/mpeg";
  FetchMediaContentTypes2["AudioOgg"] = "audio/ogg";
  FetchMediaContentTypes2["AudioOpus"] = "audio/opus";
  FetchMediaContentTypes2["AudioVorbis"] = "audio/vorbis";
  FetchMediaContentTypes2["AudioWav"] = "audio/wav";
  FetchMediaContentTypes2["AudioWebm"] = "audio/webm";
  FetchMediaContentTypes2["FontOtf"] = "font/otf";
  FetchMediaContentTypes2["FontTtf"] = "font/ttf";
  FetchMediaContentTypes2["FontWoff"] = "font/woff";
  FetchMediaContentTypes2["FontWoff2"] = "font/woff2";
  FetchMediaContentTypes2["FormData"] = "multipart/form-data";
  FetchMediaContentTypes2["FormURLEncoded"] = "application/x-www-form-urlencoded";
  FetchMediaContentTypes2["ImageAPNG"] = "image/apng";
  FetchMediaContentTypes2["ImageGIF"] = "image/gif";
  FetchMediaContentTypes2["ImageJPEG"] = "image/jpeg";
  FetchMediaContentTypes2["ImagePNG"] = "image/png";
  FetchMediaContentTypes2["ImageWEBP"] = "image/webp";
  FetchMediaContentTypes2["JSON"] = "application/json";
  FetchMediaContentTypes2["JavaScript"] = "application/javascript";
  FetchMediaContentTypes2["OctetStream"] = "application/octet-stream";
  FetchMediaContentTypes2["TextCSS"] = "text/css";
  FetchMediaContentTypes2["TextHTML"] = "text/html";
  FetchMediaContentTypes2["TextPlain"] = "text/plain";
  FetchMediaContentTypes2["VideoH264"] = "video/h264";
  FetchMediaContentTypes2["VideoH265"] = "video/h265";
  FetchMediaContentTypes2["VideoMp4"] = "video/mp4";
  FetchMediaContentTypes2["VideoOgg"] = "video/ogg";
  FetchMediaContentTypes2["VideoWebm"] = "video/webm";
  FetchMediaContentTypes2["XML"] = "application/xml";
  return FetchMediaContentTypes2;
})(FetchMediaContentTypes || {});

// src/lib/fetch.ts
async function fetch(url, options, type) {
  if (typeof options === "undefined") {
    options = {};
    type = "json" /* JSON */;
  } else if (typeof options === "string") {
    type = options;
    options = {};
  } else if (typeof type === "undefined") {
    type = "json" /* JSON */;
  }
  let { body } = options;
  if (body && typeof body === "object") {
    body = JSON.stringify(body);
  }
  const stringUrl = String(url);
  const result = await globalThis.fetch(stringUrl, { ...options, body });
  if (!result.ok)
    throw new QueryError(stringUrl, result.status, result, await result.clone().text());
  switch (type) {
    case "result" /* Result */:
      return result;
    case "buffer" /* Buffer */:
      return Buffer.from(await (await result.blob()).arrayBuffer());
    case "blob" /* Blob */:
      return result.blob();
    case "json" /* JSON */:
      return result.json();
    case "text" /* Text */:
      return result.text();
    default:
      throw new Error(`Unknown type "${type}"`);
  }
}
__name(fetch, "fetch");
export {
  FetchMediaContentTypes,
  FetchMethods,
  FetchResultTypes,
  QueryError,
  fetch
};
//# sourceMappingURL=index.mjs.map