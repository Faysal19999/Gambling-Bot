"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveMessage = void 0;
const discord_utilities_1 = require("@sapphire/discord-utilities");
const discord_js_utilities_1 = require("@sapphire/discord.js-utilities");
const pieces_1 = require("@sapphire/pieces");
const result_1 = require("@sapphire/result");
const discord_js_1 = require("discord.js");
require("../errors/Identifiers");
async function resolveMessage(parameter, options) {
    const message = (await resolveById(parameter, options)) ??
        (await resolveByLink(parameter, options)) ??
        (await resolveByChannelAndMessage(parameter, options));
    if (message) {
        return result_1.Result.ok(message);
    }
    return result_1.Result.err("messageError" /* Identifiers.ArgumentMessageError */);
}
exports.resolveMessage = resolveMessage;
function resolveById(parameter, options) {
    if (!discord_utilities_1.SnowflakeRegex.test(parameter)) {
        return null;
    }
    if (options.channel) {
        return options.channel.messages.fetch(parameter);
    }
    if (options.scan && (0, discord_js_utilities_1.isGuildBasedChannel)(options.messageOrInteraction.channel)) {
        for (const channel of options.messageOrInteraction.channel.guild.channels.cache.values()) {
            if (!(0, discord_js_utilities_1.isTextBasedChannel)(channel))
                continue;
            const message = channel.messages.cache.get(parameter);
            if (message) {
                return message;
            }
        }
    }
    return options.messageOrInteraction.channel?.messages.fetch(parameter) ?? null;
}
async function resolveByLink(parameter, options) {
    if (!options.messageOrInteraction.guild) {
        return null;
    }
    const matches = discord_utilities_1.MessageLinkRegex.exec(parameter);
    if (!matches) {
        return null;
    }
    const [, guildId, channelId, messageId] = matches;
    const guild = pieces_1.container.client.guilds.cache.get(guildId);
    if (guild !== options.messageOrInteraction.guild) {
        return null;
    }
    return getMessageFromChannel(channelId, messageId, (0, discord_js_utilities_1.isAnyInteraction)(options.messageOrInteraction) ? options.messageOrInteraction.user : options.messageOrInteraction.author);
}
async function resolveByChannelAndMessage(parameter, options) {
    const result = discord_utilities_1.ChannelMessageRegex.exec(parameter)?.groups;
    if (!result) {
        return null;
    }
    return getMessageFromChannel(result.channelId, result.messageId, (0, discord_js_utilities_1.isAnyInteraction)(options.messageOrInteraction) ? options.messageOrInteraction.user : options.messageOrInteraction.author);
}
async function getMessageFromChannel(channelId, messageId, originalAuthor) {
    const channel = pieces_1.container.client.channels.cache.get(channelId);
    if (!channel) {
        return null;
    }
    if (!((0, discord_js_utilities_1.isNewsChannel)(channel) || (0, discord_js_utilities_1.isTextChannel)(channel))) {
        return null;
    }
    if (!channel.viewable) {
        return null;
    }
    if (!channel.permissionsFor(originalAuthor)?.has(discord_js_1.Permissions.FLAGS.VIEW_CHANNEL)) {
        return null;
    }
    return channel.messages.fetch(messageId);
}
//# sourceMappingURL=message.js.map