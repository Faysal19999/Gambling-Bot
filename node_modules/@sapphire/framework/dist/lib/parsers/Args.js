"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Args = void 0;
const pieces_1 = require("@sapphire/pieces");
const result_1 = require("@sapphire/result");
const ArgumentError_1 = require("../errors/ArgumentError");
require("../errors/Identifiers");
const UserError_1 = require("../errors/UserError");
/**
 * The argument parser to be used in {@link Command}.
 */
class Args {
    constructor(message, command, parser, context) {
        /**
         * The states stored in the args.
         * @see Args#save
         * @see Args#restore
         */
        this.states = [];
        this.message = message;
        this.command = command;
        this.parser = parser;
        this.commandContext = context;
    }
    /**
     * Sets the parser to the first token.
     */
    start() {
        this.parser.reset();
        return this;
    }
    async pickResult(type, options = {}) {
        const argument = this.resolveArgument(type);
        if (!argument)
            return this.unavailableArgument(type);
        const result = await this.parser.singleParseAsync(async (arg) => argument.run(arg, {
            args: this,
            argument,
            message: this.message,
            command: this.command,
            commandContext: this.commandContext,
            ...options
        }));
        if (result.isErrAnd((value) => value === null)) {
            return this.missingArguments();
        }
        return result;
    }
    async pick(type, options) {
        const result = await this.pickResult(type, options);
        return result.unwrap();
    }
    async restResult(type, options = {}) {
        const argument = this.resolveArgument(type);
        if (!argument)
            return this.unavailableArgument(type);
        if (this.parser.finished)
            return this.missingArguments();
        const state = this.parser.save();
        const data = this.parser
            .many()
            .unwrapOr([])
            .reduce((acc, parameter) => `${acc}${parameter.leading}${parameter.value}`, '');
        const result = await argument.run(data, {
            args: this,
            argument,
            message: this.message,
            command: this.command,
            commandContext: this.commandContext,
            ...options
        });
        return result.inspectErr(() => this.parser.restore(state));
    }
    async rest(type, options) {
        const result = await this.restResult(type, options);
        return result.unwrap();
    }
    async repeatResult(type, options = {}) {
        const argument = this.resolveArgument(type);
        if (!argument)
            return this.unavailableArgument(type);
        if (this.parser.finished)
            return this.missingArguments();
        const output = [];
        for (let i = 0, times = options.times ?? Infinity; i < times; i++) {
            const result = await this.parser.singleParseAsync(async (arg) => argument.run(arg, {
                args: this,
                argument,
                message: this.message,
                command: this.command,
                commandContext: this.commandContext,
                ...options
            }));
            if (result.isErr()) {
                const error = result.unwrapErr();
                if (error === null)
                    break;
                if (output.length === 0) {
                    return result;
                }
                break;
            }
            output.push(result.unwrap());
        }
        return result_1.Result.ok(output);
    }
    async repeat(type, options) {
        const result = await this.repeatResult(type, options);
        return result.unwrap();
    }
    async peekResult(type, options = {}) {
        this.save();
        const result = typeof type === 'function' ? await type() : await this.pickResult(type, options);
        this.restore();
        return result;
    }
    async peek(type, options) {
        const result = await this.peekResult(type, options);
        return result.unwrap();
    }
    nextMaybe(cb) {
        return result_1.Option.from(typeof cb === 'function' ? this.parser.singleMap(cb) : this.parser.single());
    }
    next(cb) {
        const value = cb ? this.nextMaybe(cb) : this.nextMaybe();
        return value.unwrapOr(null);
    }
    /**
     * Checks if one or more flag were given.
     * @param keys The name(s) of the flag.
     * @example
     * ```typescript
     * // Suppose args are from '--f --g'.
     * console.log(args.getFlags('f'));
     * // >>> true
     *
     * console.log(args.getFlags('g', 'h'));
     * // >>> true
     *
     * console.log(args.getFlags('h'));
     * // >>> false
     * ```
     */
    getFlags(...keys) {
        return this.parser.flag(...keys);
    }
    /**
     * Gets the last value of one or more options as an {@link Option}.
     * If you do not care about safely handling non-existing values
     * you can use {@link Args.getOption} to get `string | null` as return type
     * @param keys The name(s) of the option.
     * @example
     * ```typescript
     * // Suppose args are from '--a=1 --b=2 --c=3'.
     * console.log(args.getOptionResult('a'));
     * // >>> Some { value: '1' }
     *
     * console.log(args.getOptionResult('b', 'c'));
     * // >>> Some { value: '2' }
     *
     * console.log(args.getOptionResult('d'));
     * // >>> None {}
     * ```
     */
    getOptionResult(...keys) {
        return this.parser.option(...keys);
    }
    /**
     * Gets the last value of one or more options.
     * Similar to {@link Args.getOptionResult} but returns the value on success, or `null` if not.
     * @param keys The name(s) of the option.
     * @example
     * ```typescript
     * // Suppose args are from '--a=1 --b=2 --c=3'.
     * console.log(args.getOption('a'));
     * // >>> '1'
     *
     * console.log(args.getOption('b', 'c'));
     * // >>> '2'
     *
     * console.log(args.getOption('d'));
     * // >>> null
     * ```
     */
    getOption(...keys) {
        return this.parser.option(...keys).unwrapOr(null);
    }
    /**
     * Gets all the values of one or more option.
     * @param keys The name(s) of the option.
     * @example
     * ```typescript
     * // Suppose args are from '--a=1 --a=1 --b=2 --c=3'.
     * console.log(args.getOptionsResult('a'));
     * // >>> Some { value: [ '1' ] }
     *
     * console.log(args.getOptionsResult('a', 'd'));
     * // >>> Some { value: [ '1' ] }
     *
     * console.log(args.getOptionsResult('b', 'c'));
     * // >>> Some { value: [ '2', '3' ] }
     *
     * console.log(args.getOptionsResult('d'));
     * // >>> None {}
     * ```
     */
    getOptionsResult(...keys) {
        return this.parser.options(...keys);
    }
    /**
     * Gets all the values of one or more option.
     * Similar to {@link Args.getOptionsResult} but returns the value on success, or `null` if not.
     * @param keys The name(s) of the option.
     * @example
     * ```typescript
     * // Suppose args are from '--a=1 --a=1 --b=2 --c=3'.
     * console.log(args.getOptions('a'));
     * // >>> ['1', '1']
     *
     * console.log(args.getOptions('b', 'c'));
     * // >>> ['2', '3']
     *
     * console.log(args.getOptions('d'));
     * // >>> null
     * ```
     */
    getOptions(...keys) {
        return this.parser.options(...keys).unwrapOr(null);
    }
    /**
     * Saves the current state into the stack following a FILO strategy (first-in, last-out).
     * @see Args#restore
     */
    save() {
        this.states.push(this.parser.save());
    }
    /**
     * Restores the previously saved state from the stack.
     * @see Args#save
     */
    restore() {
        if (this.states.length !== 0)
            this.parser.restore(this.states.pop());
    }
    /**
     * Whether all arguments have been consumed.
     */
    get finished() {
        return this.parser.finished;
    }
    /**
     * Defines the `JSON.stringify` override.
     */
    toJSON() {
        return { message: this.message, command: this.command, commandContext: this.commandContext };
    }
    unavailableArgument(type) {
        const name = typeof type === 'string' ? type : type.name;
        return result_1.Result.err(new UserError_1.UserError({
            identifier: "argsUnavailable" /* Identifiers.ArgsUnavailable */,
            message: `The argument "${name}" was not found.`,
            context: { name, ...this.toJSON() }
        }));
    }
    missingArguments() {
        return result_1.Result.err(new UserError_1.UserError({ identifier: "argsMissing" /* Identifiers.ArgsMissing */, message: 'There are no more arguments.', context: this.toJSON() }));
    }
    /**
     * Resolves an argument.
     * @param arg The argument name or {@link IArgument} instance.
     */
    resolveArgument(arg) {
        if (typeof arg === 'object')
            return arg;
        return pieces_1.container.stores.get('arguments').get(arg);
    }
    /**
     * Converts a callback into an usable argument.
     * @param cb The callback to convert into an {@link IArgument}.
     */
    static make(cb, name = '') {
        return { run: cb, name };
    }
    /**
     * Constructs an {@link Ok} result.
     * @param value The value to pass.
     */
    static ok(value) {
        return result_1.Result.ok(value);
    }
    /**
     * Constructs an {@link Err} result containing an {@link ArgumentError}.
     * @param options The options for the argument error.
     */
    static error(options) {
        return result_1.Result.err(new ArgumentError_1.ArgumentError(options));
    }
}
exports.Args = Args;
//# sourceMappingURL=Args.js.map