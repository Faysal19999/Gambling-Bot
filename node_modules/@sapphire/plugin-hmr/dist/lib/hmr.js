"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.start = void 0;
const framework_1 = require("@sapphire/framework");
const chokidar_1 = require("chokidar");
const node_path_1 = require("node:path");
/**
 * Starts HMR for all registered {@link Store Stores} in {@link container.stores the main container}.
 *
 * @param __namedParameter The {@link HMROptions}.
 * This includes [all options from chokidar](https://github.com/paulmillr/chokidar#persistence),
 * as well as whether the HMR should be enabled.
 * The default options are `{ enabled: true }`,
 * and if not provided in the object then `enabled` is also set to true.
 *
 */
function start({ enabled = true, silent = false, ...options } = { enabled: true }) {
    // Do not enable plugin when enabled is false
    if (!enabled)
        return;
    if (!silent)
        framework_1.container.logger.info('[HMR-Plugin]: Enabled. Watching for piece changes.');
    for (const store of framework_1.container.stores.values()) {
        (0, chokidar_1.watch)([...store.paths], options)
            .on('change', (path) => handlePiecePathUpdate(store, path, silent))
            .on('unlink', (path) => handlePiecePathDelete(store, path, silent));
    }
}
exports.start = start;
async function handlePiecePathDelete(store, path, silent) {
    if (!store.strategy.filter(path))
        return;
    const pieceToDelete = store.find((piece) => piece.location.full === path);
    if (!pieceToDelete)
        return;
    const result = await framework_1.Result.fromAsync(async () => {
        await pieceToDelete.unload();
        if (!silent)
            framework_1.container.logger.info(`[HMR-Plugin]: Unloaded ${pieceToDelete.name} piece from ${pieceToDelete.store.name} store.`);
    });
    result.inspectErr((error) => framework_1.container.logger.error(`[HMR-Plugin]: Failed to unload ${pieceToDelete.name} piece from ${pieceToDelete.store.name} store.`, error));
}
async function handlePiecePathUpdate(store, path, silent) {
    if (!store.strategy.filter(path))
        return;
    const pieceToUpdate = store.find((piece) => piece.location.full === path);
    const result = await framework_1.Result.fromAsync(async () => {
        if (pieceToUpdate) {
            await pieceToUpdate.reload();
            if (!silent)
                framework_1.container.logger.info(`[HMR-Plugin]: reloaded ${pieceToUpdate.name} piece from ${pieceToUpdate.store.name} store.`);
        }
        else {
            const rootPath = [...store.paths].find((storePath) => path.startsWith(storePath));
            if (!rootPath)
                throw new Error(`[HMR-Plugin]: Could not find root path for ${path}.`);
            const piecesLoaded = await store.load(rootPath, (0, node_path_1.relative)(rootPath, path));
            const piecesLoadedNames = piecesLoaded.map((piece) => piece.name);
            const piecesLoadedStoreNames = piecesLoaded.map((piece) => piece.store.name);
            if (!silent)
                framework_1.container.logger.info(`[HMR-Plugin]: Loaded ${piecesLoadedNames.join(', ')} piece(s) from ${[...new Set(piecesLoadedStoreNames)].join(', ')} store(s).`);
        }
    });
    result.inspectErr((error) => framework_1.container.logger.error(`[HMR-Plugin]: Failed to load pieces from ${path}.`, error));
}
//# sourceMappingURL=hmr.js.map