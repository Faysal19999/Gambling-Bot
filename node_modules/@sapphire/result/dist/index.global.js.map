{"version":3,"sources":["../src/index.ts","../src/lib/common/utils.ts","../src/lib/Result/ResultError.ts","../src/lib/Result/Ok.ts","../src/lib/Option/Some.ts","../src/lib/Result/Err.ts","../src/lib/Option/OptionError.ts","../src/lib/Option/None.ts","../src/lib/Option.ts","../src/lib/Result.ts"],"sourcesContent":["export * from './lib/Option';\nexport * from './lib/Result';\n","export type Awaitable<T> = PromiseLike<T> | T;\n\nexport function isFunction<A extends readonly any[], R>(cb: (...args: A) => R): true;\nexport function isFunction(input: any): input is (...args: readonly any[]) => any;\nexport function isFunction(input: any) {\n\treturn typeof input === 'function';\n}\n\nexport function isPromise<T>(input: PromiseLike<T>): true;\nexport function isPromise(input: any): input is PromiseLike<any>;\nexport function isPromise(input: any) {\n\treturn typeof input === 'object' && input !== null && typeof input.then === 'function';\n}\n","export class ResultError<E> extends Error {\n\tpublic readonly value: E;\n\n\tpublic constructor(message: string, value: E) {\n\t\tsuper(message);\n\t\tthis.value = value;\n\t}\n\n\tpublic override get name(): string {\n\t\treturn this.constructor.name;\n\t}\n}\n","import type { Awaitable } from '../common/utils';\nimport type { Option } from '../Option';\nimport { none, type None } from '../Option/None';\nimport { some, type Some } from '../Option/Some';\nimport type { Result } from '../Result';\nimport type { Err } from './Err';\nimport type { IResult } from './IResult';\nimport { ResultError } from './ResultError';\n\nexport class Ok<T> implements IResult<T, any> {\n\tprivate readonly value: T;\n\n\tpublic constructor(value: T) {\n\t\tthis.value = value;\n\t}\n\n\tpublic isOk(): this is Ok<T> {\n\t\treturn true;\n\t}\n\n\tpublic isOkAnd<R extends boolean>(cb: (value: T) => R): R {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic isErr(): false {\n\t\treturn false;\n\t}\n\n\tpublic isErrAnd(cb?: (error: never) => boolean): false;\n\tpublic isErrAnd(): false {\n\t\treturn false;\n\t}\n\n\tpublic ok(): Some<T> {\n\t\treturn some(this.value);\n\t}\n\n\tpublic err(): None {\n\t\treturn none;\n\t}\n\n\tpublic map<U>(cb: (value: T) => U): Ok<U> {\n\t\treturn ok(cb(this.value));\n\t}\n\n\tpublic mapInto<R extends Result<any, any>>(cb: (value: T) => R): R {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic mapOr<U>(_: U, cb: (value: T) => U): U {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic mapOrElse<U>(_: (error: never) => U, cb: (value: T) => U): U {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic mapErr(cb?: (error: never) => any): this;\n\tpublic mapErr(): this {\n\t\treturn this;\n\t}\n\n\tpublic mapErrInto(cb: (error: never) => Result<any, any>): this;\n\tpublic mapErrInto(): this {\n\t\treturn this;\n\t}\n\n\tpublic inspect(cb: (value: T) => void): this {\n\t\tcb(this.value);\n\t\treturn this;\n\t}\n\n\tpublic async inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this> {\n\t\tawait cb(this.value);\n\t\treturn this;\n\t}\n\n\tpublic inspectErr(cb?: (error: never) => void): this;\n\tpublic inspectErr(): this {\n\t\treturn this;\n\t}\n\n\tpublic inspectErrAsync(cb?: (error: never) => Awaitable<unknown>): Promise<this>;\n\tpublic inspectErrAsync(): Promise<this> {\n\t\treturn Promise.resolve(this);\n\t}\n\n\tpublic *iter(): Generator<T> {\n\t\tyield this.value;\n\t}\n\n\tpublic expect(message?: string): T;\n\tpublic expect(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic expectErr(message: string): never {\n\t\tthrow new ResultError(message, this.value);\n\t}\n\n\tpublic unwrap(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic unwrapErr(): never {\n\t\tthrow new ResultError('Unwrap failed', this.value);\n\t}\n\n\tpublic unwrapOr(defaultValue: unknown): T;\n\tpublic unwrapOr(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic unwrapOrElse(op: (error: any) => unknown): T;\n\tpublic unwrapOrElse(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic and<R extends Result<any, any>>(result: R): R {\n\t\treturn result;\n\t}\n\n\tpublic andThen<R extends Result<any, any>>(cb: (value: T) => R): R {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic or(result: Result<T, any>): this;\n\tpublic or(): this {\n\t\treturn this;\n\t}\n\n\tpublic orElse(cb: (error: never) => Result<T, any>): this;\n\tpublic orElse(): this {\n\t\treturn this;\n\t}\n\n\tpublic contains(value: T): boolean {\n\t\treturn this.value === value;\n\t}\n\n\tpublic containsErr(error?: unknown): false;\n\tpublic containsErr(): false {\n\t\treturn false;\n\t}\n\n\tpublic transpose(this: Ok<None>): None;\n\tpublic transpose<Inner>(this: Ok<Some<Inner>>): Some<Ok<Inner>>;\n\tpublic transpose<Inner>(this: Ok<Option<Inner>>): Option<Ok<Inner>>;\n\tpublic transpose<IT>(this: Ok<Option<IT>>): Option<Ok<IT>> {\n\t\treturn this.value.match({\n\t\t\tsome: (value) => some(ok(value)),\n\t\t\tnone: () => none\n\t\t});\n\t}\n\n\tpublic flatten<Inner extends Result<any, any>>(this: Ok<Inner>): Inner {\n\t\treturn this.value;\n\t}\n\n\tpublic intoOkOrErr() {\n\t\treturn this.value;\n\t}\n\n\tpublic async intoPromise(): Promise<Ok<Awaited<T>>> {\n\t\treturn ok(await this.value);\n\t}\n\n\tpublic eq(other: Err<any>): false;\n\tpublic eq(other: Result<T, any>): boolean;\n\tpublic eq(other: Result<T, any>): boolean {\n\t\treturn other.isOkAnd((value) => this.value === value);\n\t}\n\n\tpublic ne(other: Err<any>): true;\n\tpublic ne(other: Result<T, any>): boolean;\n\tpublic ne(other: Result<T, any>): boolean {\n\t\treturn !this.eq(other);\n\t}\n\n\tpublic match<OkValue, ErrValue>(branches: { ok(value: T): OkValue; err(error: never): ErrValue }): OkValue {\n\t\treturn branches.ok(this.value);\n\t}\n\n\tpublic *[Symbol.iterator](): Generator<T> {\n\t\tyield this.value;\n\t}\n}\n\n/**\n * Creates an Ok with no value.\n * @return A successful Result.\n */\nexport function ok(): Ok<unknown>;\n\n/**\n * Creates an Ok.\n * @typeparam T The result's type.\n * @param x Value to use.\n * @return A successful Result.\n */\nexport function ok<T>(x: T): Ok<T>;\nexport function ok<T>(x?: T): Ok<T | undefined> {\n\treturn new Ok(x);\n}\n","import type { Awaitable } from '../common/utils';\nimport type { Option } from '../Option';\nimport type { Result } from '../Result';\nimport { err, type Err } from '../Result/Err';\nimport { ok, type Ok } from '../Result/Ok';\nimport type { IOption } from './IOption';\nimport { none, type None } from './None';\n\nexport class Some<T> implements IOption<T> {\n\tprivate readonly value: T;\n\n\tpublic constructor(value: T) {\n\t\tthis.value = value;\n\t}\n\n\tpublic isSome(): this is Some<T> {\n\t\treturn true;\n\t}\n\n\tpublic isSomeAnd<R extends boolean>(cb: (value: T) => R): R {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic isNone(): false {\n\t\treturn false;\n\t}\n\n\tpublic expect(message: string): T;\n\tpublic expect(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic unwrap(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic unwrapOr(defaultValue: unknown): T;\n\tpublic unwrapOr(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic unwrapOrElse(cb: () => unknown): T;\n\tpublic unwrapOrElse(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic map<U>(cb: (value: T) => U): Some<U> {\n\t\treturn some(cb(this.value));\n\t}\n\n\tpublic mapInto<R extends Option<any>>(cb: (value: T) => R): R {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic mapOr<U>(_: U, cb: (value: T) => U): U {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic mapOrElse<U>(_: () => U, cb: (value: T) => U): U {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic mapNoneInto(cb: () => Option<any>): this;\n\tpublic mapNoneInto(): this {\n\t\treturn this;\n\t}\n\n\tpublic inspect(cb: (value: T) => void): this {\n\t\tcb(this.value);\n\t\treturn this;\n\t}\n\n\tpublic async inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this> {\n\t\tawait cb(this.value);\n\t\treturn this;\n\t}\n\n\tpublic okOr(err?: any): Ok<T>;\n\tpublic okOr(): Ok<T> {\n\t\treturn ok(this.value);\n\t}\n\n\tpublic okOrElse(cb: () => any): Ok<T>;\n\tpublic okOrElse(): Ok<T> {\n\t\treturn ok(this.value);\n\t}\n\n\tpublic *iter(): Generator<T> {\n\t\tyield this.value;\n\t}\n\n\tpublic and<R extends Option<any>>(option: R): R {\n\t\treturn option;\n\t}\n\n\tpublic andThen<R extends Option<any>>(cb: (value: T) => R): R {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic or(option: Option<any>): this;\n\tpublic or(): this {\n\t\treturn this;\n\t}\n\n\tpublic orElse(cb?: () => Option<any>): this;\n\tpublic orElse(): this {\n\t\treturn this;\n\t}\n\n\tpublic xor(option: Some<T>): None;\n\tpublic xor(option: None): this;\n\tpublic xor(option: Option<T>): this | None;\n\tpublic xor(option: Option<T>): this | None {\n\t\treturn option.isSome() ? none : this;\n\t}\n\n\tpublic filter(predicate: (value: T) => true): this;\n\tpublic filter(predicate: (value: T) => false): None;\n\tpublic filter(predicate: (value: T) => boolean): this | None;\n\tpublic filter(predicate: (value: T) => boolean): this | None {\n\t\treturn predicate(this.value) ? this : none;\n\t}\n\n\tpublic contains(value: T): boolean {\n\t\treturn this.value === value;\n\t}\n\n\tpublic zip(other: None): None;\n\tpublic zip<U>(other: Some<U>): Some<[T, U]>;\n\tpublic zip<U>(other: Option<U>): Option<[T, U]>;\n\tpublic zip<U>(other: Option<U>): Option<[T, U]> {\n\t\treturn other.map((o) => [this.value, o] as [T, U]);\n\t}\n\n\tpublic zipWith<U, R>(other: None, f: (s: T, o: U) => R): None;\n\tpublic zipWith<U, R>(other: Some<U>, f: (s: T, o: U) => R): Some<R>;\n\tpublic zipWith<U, R>(other: Option<U>, f: (s: T, o: U) => R): Option<R>;\n\tpublic zipWith<U, R>(other: Option<U>, f: (s: T, o: U) => R): Option<R> {\n\t\treturn other.map((o) => f(this.value, o));\n\t}\n\n\tpublic unzip<I, U>(this: Some<readonly [I, U]>): [Some<I>, Some<U>] {\n\t\tconst [s, o] = this.value;\n\t\treturn [some(s), some(o)];\n\t}\n\n\tpublic transpose<Inner>(this: Some<Ok<Inner>>): Ok<Some<Inner>>;\n\tpublic transpose<Inner>(this: Some<Err<Inner>>): Err<Some<Inner>>;\n\tpublic transpose<IT, E>(this: Some<Result<IT, E>>): Result<Some<IT>, E>;\n\tpublic transpose<IT, E>(this: Some<Result<IT, E>>): Result<Some<IT>, E> {\n\t\treturn this.value.match({\n\t\t\tok: (v) => ok(some(v)),\n\t\t\terr: (e) => err(e)\n\t\t});\n\t}\n\n\tpublic flatten<Inner extends Option<any>>(this: Some<Inner>): Inner {\n\t\treturn this.value;\n\t}\n\n\tpublic async intoPromise(): Promise<Some<Awaited<T>>> {\n\t\treturn some(await this.value);\n\t}\n\n\tpublic eq(other: None): false;\n\tpublic eq(other: Option<T>): boolean;\n\tpublic eq(other: Option<T>): boolean {\n\t\treturn other.isSomeAnd((value) => this.value === value);\n\t}\n\n\tpublic ne(other: None): true;\n\tpublic ne(other: Option<T>): boolean;\n\tpublic ne(other: Option<T>): boolean {\n\t\treturn !this.eq(other);\n\t}\n\n\tpublic match<SomeValue, NoneValue>(branches: { some(value: T): SomeValue; none(): NoneValue }): SomeValue {\n\t\treturn branches.some(this.value);\n\t}\n\n\tpublic *[Symbol.iterator](): Generator<T> {\n\t\tyield this.value;\n\t}\n}\n\nexport function some<T>(value: T): Some<T> {\n\treturn new Some<T>(value);\n}\n","import type { Awaitable } from '../common/utils';\nimport { none, type None } from '../Option/None';\nimport { some, type Some } from '../Option/Some';\nimport type { Result } from '../Result';\nimport type { IResult } from './IResult';\nimport type { Ok } from './Ok';\nimport { ResultError } from './ResultError';\n\nexport class Err<E> implements IResult<any, E> {\n\tprivate readonly error: E;\n\n\tpublic constructor(error: E) {\n\t\tthis.error = error;\n\t}\n\n\tpublic isOk(): false {\n\t\treturn false;\n\t}\n\n\tpublic isOkAnd(cb?: (value: never) => boolean): false;\n\tpublic isOkAnd(): false {\n\t\treturn false;\n\t}\n\n\tpublic isErr(): this is Err<E> {\n\t\treturn true;\n\t}\n\n\tpublic isErrAnd(cb: (error: E) => boolean): boolean {\n\t\treturn cb(this.error);\n\t}\n\n\tpublic ok(): None {\n\t\treturn none;\n\t}\n\n\tpublic err(): Some<E> {\n\t\treturn some(this.error);\n\t}\n\n\tpublic map(cb?: (value: never) => unknown): this;\n\tpublic map(): this {\n\t\treturn this;\n\t}\n\n\tpublic mapInto(cb: (value: never) => Result<any, any>): this;\n\tpublic mapInto(): this {\n\t\treturn this;\n\t}\n\n\tpublic mapOr<U>(defaultValue: U, cb?: (value: never) => U): U;\n\tpublic mapOr<U>(defaultValue: U): U {\n\t\treturn defaultValue;\n\t}\n\n\tpublic mapOrElse<U>(op: (error: E) => U, cb?: (value: never) => U): U;\n\tpublic mapOrElse<U>(op: (error: E) => U): U {\n\t\treturn op(this.error);\n\t}\n\n\tpublic mapErr<F>(cb: (error: E) => F): Err<F> {\n\t\treturn err(cb(this.error));\n\t}\n\n\tpublic mapErrInto<R extends Result<any, any>>(cb: (error: E) => R): R {\n\t\treturn cb(this.error);\n\t}\n\n\tpublic inspect(cb?: (value: never) => void): this;\n\tpublic inspect(): this {\n\t\treturn this;\n\t}\n\n\tpublic inspectAsync(cb?: (value: never) => Awaitable<unknown>): Promise<this>;\n\tpublic inspectAsync(): Promise<this> {\n\t\treturn Promise.resolve(this);\n\t}\n\n\tpublic inspectErr(cb: (error: E) => void): this {\n\t\tcb(this.error);\n\t\treturn this;\n\t}\n\n\tpublic async inspectErrAsync(cb: (error: E) => Awaitable<unknown>): Promise<this> {\n\t\tawait cb(this.error);\n\t\treturn this;\n\t}\n\n\tpublic *iter(): Generator<never> {\n\t\t// Yields no values\n\t}\n\n\tpublic expect(message: string): never {\n\t\tthrow new ResultError(message, this.error);\n\t}\n\n\tpublic expectErr(message?: string): E;\n\tpublic expectErr(): E {\n\t\treturn this.error;\n\t}\n\n\tpublic unwrap(): never {\n\t\tthrow new ResultError('Unwrap failed', this.error);\n\t}\n\n\tpublic unwrapErr(): E {\n\t\treturn this.error;\n\t}\n\n\tpublic unwrapOr<T>(defaultValue: T): T {\n\t\treturn defaultValue;\n\t}\n\n\tpublic unwrapOrElse<T>(op: (error: E) => T): T {\n\t\treturn op(this.error);\n\t}\n\n\tpublic and(result?: Result<any, E>): this;\n\tpublic and(): this {\n\t\treturn this;\n\t}\n\n\tpublic andThen(cb?: (value: never) => Result<any, E>): this;\n\tpublic andThen(): this {\n\t\treturn this;\n\t}\n\n\tpublic or<R extends Result<any, any>>(result: R): R {\n\t\treturn result;\n\t}\n\n\tpublic orElse<R extends Result<any, any>>(cb: (error: E) => R): R {\n\t\treturn cb(this.error);\n\t}\n\n\tpublic contains(value?: any): false;\n\tpublic contains(): false {\n\t\treturn false;\n\t}\n\n\tpublic containsErr(error: E): boolean {\n\t\treturn this.error === error;\n\t}\n\n\tpublic transpose(): Some<this> {\n\t\treturn some(this);\n\t}\n\n\tpublic flatten(): this {\n\t\treturn this;\n\t}\n\n\tpublic intoOkOrErr(): E {\n\t\treturn this.error;\n\t}\n\n\tpublic async intoPromise(): Promise<Err<Awaited<E>>> {\n\t\treturn err(await this.error);\n\t}\n\n\tpublic eq(other: Ok<any>): false;\n\tpublic eq(other: Result<any, E>): boolean;\n\tpublic eq(other: Result<any, E>): boolean {\n\t\treturn other.isErrAnd((error) => this.error === error);\n\t}\n\n\tpublic ne(other: Ok<any>): true;\n\tpublic ne(other: Result<any, E>): boolean;\n\tpublic ne(other: Result<any, E>): boolean {\n\t\treturn !this.eq(other);\n\t}\n\n\tpublic match<OkValue, ErrValue>(branches: { ok(value: never): OkValue; err(error: E): ErrValue }): ErrValue {\n\t\treturn branches.err(this.error);\n\t}\n\n\tpublic *[Symbol.iterator](): Generator<never> {\n\t\t// Yields no values\n\t}\n}\n\n/**\n * Creates an Err with no error.\n * @return An erroneous Result.\n */\nexport function err(): Err<unknown>;\n\n/**\n * Creates an Err.\n * @typeparam E The error's type.\n * @param x Value to use.\n * @return An erroneous Result.\n */\nexport function err<E>(x: E): Err<E>;\nexport function err<E>(x?: E): Err<unknown> {\n\treturn new Err(x);\n}\n","export class OptionError extends Error {\n\tpublic override get name(): string {\n\t\treturn this.constructor.name;\n\t}\n}\n","import type { Awaitable } from '../common/utils';\nimport type { Option } from '../Option';\nimport { err, type Err } from '../Result/Err';\nimport { ok, type Ok } from '../Result/Ok';\nimport type { IOption } from './IOption';\nimport { OptionError } from './OptionError';\nimport type { Some } from './Some';\n\nexport class None implements IOption<any> {\n\tpublic isSome(): false {\n\t\treturn false;\n\t}\n\n\tpublic isSomeAnd(cb?: (value: never) => boolean): false;\n\tpublic isSomeAnd(): false {\n\t\treturn false;\n\t}\n\n\tpublic isNone(): this is None {\n\t\treturn true;\n\t}\n\n\tpublic expect(message: string): never {\n\t\tthrow new OptionError(message);\n\t}\n\n\tpublic unwrap(): never {\n\t\tthrow new OptionError('Unwrap failed');\n\t}\n\n\tpublic unwrapOr<R>(defaultValue: R): R {\n\t\treturn defaultValue;\n\t}\n\n\tpublic unwrapOrElse<R>(cb: () => R): R {\n\t\treturn cb();\n\t}\n\n\tpublic map(cb: (value: never) => any): this;\n\tpublic map(): this {\n\t\treturn this;\n\t}\n\n\tpublic mapInto(cb: (value: never) => Option<any>): this;\n\tpublic mapInto(): this {\n\t\treturn this;\n\t}\n\n\tpublic mapOr<R>(defaultValue: R, cb?: (value: never) => R): R;\n\tpublic mapOr<R>(defaultValue: R): R {\n\t\treturn defaultValue;\n\t}\n\n\tpublic mapOrElse<R>(defaultValue: () => R, cb?: (value: never) => R): R;\n\tpublic mapOrElse<R>(defaultValue: () => R): R {\n\t\treturn defaultValue();\n\t}\n\n\tpublic mapNoneInto<R extends Option<any>>(cb: () => R): R {\n\t\treturn cb();\n\t}\n\n\tpublic inspect(cb?: (value: never) => void): this;\n\tpublic inspect(): this {\n\t\treturn this;\n\t}\n\n\tpublic inspectAsync(cb?: (value: never) => Awaitable<unknown>): Promise<this>;\n\tpublic inspectAsync(): Promise<this> {\n\t\treturn Promise.resolve(this);\n\t}\n\n\tpublic okOr<E>(error: E): Err<E> {\n\t\treturn err(error);\n\t}\n\n\tpublic okOrElse<E>(cb: () => E): Err<E> {\n\t\treturn err(cb());\n\t}\n\n\tpublic *iter(): Generator<never> {\n\t\t// Yields no values\n\t}\n\n\tpublic and(option: Option<any>): this;\n\tpublic and(): this {\n\t\treturn this;\n\t}\n\n\tpublic andThen(cb: (value: never) => Option<any>): this;\n\tpublic andThen(): this {\n\t\treturn this;\n\t}\n\n\tpublic or<R extends Option<any>>(option: R): R {\n\t\treturn option;\n\t}\n\n\tpublic orElse<R extends Option<any>>(cb: () => R): R {\n\t\treturn cb();\n\t}\n\n\tpublic xor<T>(option: None): None;\n\tpublic xor<T>(option: Some<T>): Some<T>;\n\tpublic xor<T>(option: Option<T>): Some<T> | None;\n\tpublic xor<T>(option: Some<T> | None): Some<T> | None {\n\t\treturn option.isSome() ? option : this;\n\t}\n\n\tpublic filter(predicate: (value: never) => boolean): None;\n\tpublic filter(): None {\n\t\treturn this;\n\t}\n\n\tpublic contains(value?: any): false;\n\tpublic contains(): false {\n\t\treturn false;\n\t}\n\n\tpublic zip(other: Option<any>): None;\n\tpublic zip(): None {\n\t\treturn this;\n\t}\n\n\tpublic zipWith(other: Option<any>, f: (s: never, o: never) => any): None;\n\tpublic zipWith(): None {\n\t\treturn this;\n\t}\n\n\tpublic unzip(): [None, None] {\n\t\treturn [this, this];\n\t}\n\n\tpublic transpose(): Ok<None> {\n\t\treturn ok(this);\n\t}\n\n\tpublic flatten(): None {\n\t\treturn this;\n\t}\n\n\tpublic intoPromise(): Promise<None> {\n\t\treturn Promise.resolve(none);\n\t}\n\n\tpublic eq(other: None): true;\n\tpublic eq(other: Some<any>): false;\n\tpublic eq(other: Option<any>): boolean;\n\tpublic eq(other: Option<any>): boolean {\n\t\treturn other.isNone();\n\t}\n\n\tpublic ne(other: None): false;\n\tpublic ne(other: Some<any>): true;\n\tpublic ne(other: Option<any>): boolean;\n\tpublic ne(other: Option<any>): boolean {\n\t\treturn other.isSome();\n\t}\n\n\tpublic match<SomeValue, NoneValue>(branches: { some(value: never): SomeValue; none(): NoneValue }): NoneValue {\n\t\treturn branches.none();\n\t}\n\n\tpublic *[Symbol.iterator](): Generator<never> {\n\t\t// Yields no values\n\t}\n}\n\nexport const none = new None();\n","import { Awaitable, isFunction } from './common/utils';\nimport { None, none as _none } from './Option/None';\nimport { Some, some as _some } from './Option/Some';\n\nexport * from './Option/IOption';\nexport * from './Option/OptionError';\nexport { _some as some, _none as none };\n\n/**\n * The union of the two variations of `Option`.\n * @typeparam T The value's type.\n */\nexport type Option<T> = Option.Some<T> | Option.None;\n\nexport namespace Option {\n\texport type Resolvable<T> = T | null | undefined | Option<T>;\n\tfunction resolve<T>(value: Resolvable<T>) {\n\t\tif (value === null || value === undefined) return none;\n\t\tif (is(value)) return value;\n\t\treturn some(value);\n\t}\n\n\texport function is<T>(value: Option<T>): true;\n\texport function is(value: any): value is Option<unknown>;\n\texport function is(value: any) {\n\t\treturn value instanceof None || value instanceof Some;\n\t}\n\n\t/**\n\t * Creates an {@link Option} out of a value or callback.\n\t * @typeparam T The result's type.\n\t */\n\texport function from<T>(op: Resolvable<T> | (() => Resolvable<T>)): Option<T> {\n\t\tif (!isFunction(op)) return resolve(op);\n\n\t\ttry {\n\t\t\treturn resolve(op());\n\t\t} catch {\n\t\t\treturn none;\n\t\t}\n\t}\n\n\t/**\n\t * Creates an {@link Option} out of a value or callback.\n\t * @typeparam T The result's type.\n\t */\n\texport async function fromAsync<T>(op: Awaitable<Resolvable<T>> | (() => Awaitable<Resolvable<T>>)): Promise<Option<T>> {\n\t\ttry {\n\t\t\treturn resolve(await (isFunction(op) ? op() : op));\n\t\t} catch {\n\t\t\treturn none;\n\t\t}\n\t}\n\n\texport const none = _none;\n\texport const some = _some;\n\n\texport type Some<T> = import('./Option/Some').Some<T>;\n\texport type None = import('./Option/None').None;\n\n\texport type UnwrapSome<T extends Option<any>> = T extends Some<infer S> ? S : never;\n}\n","import { isFunction, type Awaitable } from './common/utils';\nimport { Err, err as _err } from './Result/Err';\nimport { Ok, ok as _ok } from './Result/Ok';\n\nexport * from './Result/IResult';\nexport * from './Result/ResultError';\nexport { _ok as ok, _err as err };\n\n/**\n * The union of the two variations of `Result`.\n * @typeparam T The result's type.\n * @typeparam E The error's type.\n */\nexport type Result<T, E> = Result.Ok<T> | Result.Err<E>;\n\nexport namespace Result {\n\texport type Resolvable<T, E> = T | Result<T, E>;\n\tfunction resolve<T, E>(value: Resolvable<T, E>) {\n\t\tif (is(value)) return value;\n\t\treturn ok(value);\n\t}\n\n\texport function is<T, E>(value: Result<T, E>): true;\n\texport function is(value: any): value is Result<unknown, unknown>;\n\texport function is(value: any) {\n\t\treturn value instanceof Ok || value instanceof Err;\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a callback.\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\texport function from<T, E = unknown>(op: Resolvable<T, E> | (() => Resolvable<T, E>)): Result<T, E> {\n\t\tif (!isFunction(op)) return resolve(op);\n\n\t\ttry {\n\t\t\treturn resolve(op());\n\t\t} catch (error) {\n\t\t\treturn err(error as E);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a promise or async callback.\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\texport async function fromAsync<T, E = unknown>(op: Awaitable<Resolvable<T, E>> | (() => Awaitable<Resolvable<T, E>>)): Promise<Result<T, E>> {\n\t\ttry {\n\t\t\treturn resolve(await (isFunction(op) ? op() : op));\n\t\t} catch (error) {\n\t\t\treturn err(error as E);\n\t\t}\n\t}\n\n\texport const err = _err;\n\texport const ok = _ok;\n\n\texport type Err<E> = import('./Result/Err').Err<E>;\n\texport type Ok<T> = import('./Result/Ok').Ok<T>;\n\n\texport type UnwrapOk<T extends Result<any, any>> = T extends Ok<infer S> ? S : never;\n\texport type UnwrapErr<T extends Result<any, any>> = T extends Err<infer S> ? S : never;\n}\n"],"mappings":"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","names":["Option","Result"]}