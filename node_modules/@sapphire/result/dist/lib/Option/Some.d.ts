import type { Awaitable } from '../common/utils';
import type { Option } from '../Option';
import type { Result } from '../Result';
import { type Err } from '../Result/Err';
import { type Ok } from '../Result/Ok';
import type { IOption } from './IOption';
import { type None } from './None';
export declare class Some<T> implements IOption<T> {
    private readonly value;
    constructor(value: T);
    isSome(): this is Some<T>;
    isSomeAnd<R extends boolean>(cb: (value: T) => R): R;
    isNone(): false;
    expect(message: string): T;
    unwrap(): T;
    unwrapOr(defaultValue: unknown): T;
    unwrapOrElse(cb: () => unknown): T;
    map<U>(cb: (value: T) => U): Some<U>;
    mapInto<R extends Option<any>>(cb: (value: T) => R): R;
    mapOr<U>(_: U, cb: (value: T) => U): U;
    mapOrElse<U>(_: () => U, cb: (value: T) => U): U;
    mapNoneInto(cb: () => Option<any>): this;
    inspect(cb: (value: T) => void): this;
    inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this>;
    okOr(err?: any): Ok<T>;
    okOrElse(cb: () => any): Ok<T>;
    iter(): Generator<T>;
    and<R extends Option<any>>(option: R): R;
    andThen<R extends Option<any>>(cb: (value: T) => R): R;
    or(option: Option<any>): this;
    orElse(cb?: () => Option<any>): this;
    xor(option: Some<T>): None;
    xor(option: None): this;
    xor(option: Option<T>): this | None;
    filter(predicate: (value: T) => true): this;
    filter(predicate: (value: T) => false): None;
    filter(predicate: (value: T) => boolean): this | None;
    contains(value: T): boolean;
    zip(other: None): None;
    zip<U>(other: Some<U>): Some<[T, U]>;
    zip<U>(other: Option<U>): Option<[T, U]>;
    zipWith<U, R>(other: None, f: (s: T, o: U) => R): None;
    zipWith<U, R>(other: Some<U>, f: (s: T, o: U) => R): Some<R>;
    zipWith<U, R>(other: Option<U>, f: (s: T, o: U) => R): Option<R>;
    unzip<I, U>(this: Some<readonly [I, U]>): [Some<I>, Some<U>];
    transpose<Inner>(this: Some<Ok<Inner>>): Ok<Some<Inner>>;
    transpose<Inner>(this: Some<Err<Inner>>): Err<Some<Inner>>;
    transpose<IT, E>(this: Some<Result<IT, E>>): Result<Some<IT>, E>;
    flatten<Inner extends Option<any>>(this: Some<Inner>): Inner;
    intoPromise(): Promise<Some<Awaited<T>>>;
    eq(other: None): false;
    eq(other: Option<T>): boolean;
    ne(other: None): true;
    ne(other: Option<T>): boolean;
    match<SomeValue, NoneValue>(branches: {
        some(value: T): SomeValue;
        none(): NoneValue;
    }): SomeValue;
    [Symbol.iterator](): Generator<T>;
}
export declare function some<T>(value: T): Some<T>;
//# sourceMappingURL=Some.d.ts.map