import type { Awaitable } from '../common/utils';
import type { Option } from '../Option';
import { type None } from '../Option/None';
import { type Some } from '../Option/Some';
import type { Result } from '../Result';
import type { Err } from './Err';
import type { IResult } from './IResult';
export declare class Ok<T> implements IResult<T, any> {
    private readonly value;
    constructor(value: T);
    isOk(): this is Ok<T>;
    isOkAnd<R extends boolean>(cb: (value: T) => R): R;
    isErr(): false;
    isErrAnd(cb?: (error: never) => boolean): false;
    ok(): Some<T>;
    err(): None;
    map<U>(cb: (value: T) => U): Ok<U>;
    mapInto<R extends Result<any, any>>(cb: (value: T) => R): R;
    mapOr<U>(_: U, cb: (value: T) => U): U;
    mapOrElse<U>(_: (error: never) => U, cb: (value: T) => U): U;
    mapErr(cb?: (error: never) => any): this;
    mapErrInto(cb: (error: never) => Result<any, any>): this;
    inspect(cb: (value: T) => void): this;
    inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this>;
    inspectErr(cb?: (error: never) => void): this;
    inspectErrAsync(cb?: (error: never) => Awaitable<unknown>): Promise<this>;
    iter(): Generator<T>;
    expect(message?: string): T;
    expectErr(message: string): never;
    unwrap(): T;
    unwrapErr(): never;
    unwrapOr(defaultValue: unknown): T;
    unwrapOrElse(op: (error: any) => unknown): T;
    and<R extends Result<any, any>>(result: R): R;
    andThen<R extends Result<any, any>>(cb: (value: T) => R): R;
    or(result: Result<T, any>): this;
    orElse(cb: (error: never) => Result<T, any>): this;
    contains(value: T): boolean;
    containsErr(error?: unknown): false;
    transpose(this: Ok<None>): None;
    transpose<Inner>(this: Ok<Some<Inner>>): Some<Ok<Inner>>;
    transpose<Inner>(this: Ok<Option<Inner>>): Option<Ok<Inner>>;
    flatten<Inner extends Result<any, any>>(this: Ok<Inner>): Inner;
    intoOkOrErr(): T;
    intoPromise(): Promise<Ok<Awaited<T>>>;
    eq(other: Err<any>): false;
    eq(other: Result<T, any>): boolean;
    ne(other: Err<any>): true;
    ne(other: Result<T, any>): boolean;
    match<OkValue, ErrValue>(branches: {
        ok(value: T): OkValue;
        err(error: never): ErrValue;
    }): OkValue;
    [Symbol.iterator](): Generator<T>;
}
/**
 * Creates an Ok with no value.
 * @return A successful Result.
 */
export declare function ok(): Ok<unknown>;
/**
 * Creates an Ok.
 * @typeparam T The result's type.
 * @param x Value to use.
 * @return A successful Result.
 */
export declare function ok<T>(x: T): Ok<T>;
//# sourceMappingURL=Ok.d.ts.map