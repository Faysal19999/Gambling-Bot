import type { Awaitable } from '../common/utils';
import { type None } from '../Option/None';
import { type Some } from '../Option/Some';
import type { Result } from '../Result';
import type { IResult } from './IResult';
import type { Ok } from './Ok';
export declare class Err<E> implements IResult<any, E> {
    private readonly error;
    constructor(error: E);
    isOk(): false;
    isOkAnd(cb?: (value: never) => boolean): false;
    isErr(): this is Err<E>;
    isErrAnd(cb: (error: E) => boolean): boolean;
    ok(): None;
    err(): Some<E>;
    map(cb?: (value: never) => unknown): this;
    mapInto(cb: (value: never) => Result<any, any>): this;
    mapOr<U>(defaultValue: U, cb?: (value: never) => U): U;
    mapOrElse<U>(op: (error: E) => U, cb?: (value: never) => U): U;
    mapErr<F>(cb: (error: E) => F): Err<F>;
    mapErrInto<R extends Result<any, any>>(cb: (error: E) => R): R;
    inspect(cb?: (value: never) => void): this;
    inspectAsync(cb?: (value: never) => Awaitable<unknown>): Promise<this>;
    inspectErr(cb: (error: E) => void): this;
    inspectErrAsync(cb: (error: E) => Awaitable<unknown>): Promise<this>;
    iter(): Generator<never>;
    expect(message: string): never;
    expectErr(message?: string): E;
    unwrap(): never;
    unwrapErr(): E;
    unwrapOr<T>(defaultValue: T): T;
    unwrapOrElse<T>(op: (error: E) => T): T;
    and(result?: Result<any, E>): this;
    andThen(cb?: (value: never) => Result<any, E>): this;
    or<R extends Result<any, any>>(result: R): R;
    orElse<R extends Result<any, any>>(cb: (error: E) => R): R;
    contains(value?: any): false;
    containsErr(error: E): boolean;
    transpose(): Some<this>;
    flatten(): this;
    intoOkOrErr(): E;
    intoPromise(): Promise<Err<Awaited<E>>>;
    eq(other: Ok<any>): false;
    eq(other: Result<any, E>): boolean;
    ne(other: Ok<any>): true;
    ne(other: Result<any, E>): boolean;
    match<OkValue, ErrValue>(branches: {
        ok(value: never): OkValue;
        err(error: E): ErrValue;
    }): ErrValue;
    [Symbol.iterator](): Generator<never>;
}
/**
 * Creates an Err with no error.
 * @return An erroneous Result.
 */
export declare function err(): Err<unknown>;
/**
 * Creates an Err.
 * @typeparam E The error's type.
 * @param x Value to use.
 * @return An erroneous Result.
 */
export declare function err<E>(x: E): Err<E>;
//# sourceMappingURL=Err.d.ts.map