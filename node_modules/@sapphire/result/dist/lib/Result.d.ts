import { type Awaitable } from './common/utils';
import { err as _err } from './Result/Err';
import { ok as _ok } from './Result/Ok';
export * from './Result/IResult';
export * from './Result/ResultError';
export { _ok as ok, _err as err };
/**
 * The union of the two variations of `Result`.
 * @typeparam T The result's type.
 * @typeparam E The error's type.
 */
export declare type Result<T, E> = Result.Ok<T> | Result.Err<E>;
export declare namespace Result {
    type Resolvable<T, E> = T | Result<T, E>;
    function is<T, E>(value: Result<T, E>): true;
    function is(value: any): value is Result<unknown, unknown>;
    /**
     * Creates a {@link Result} out of a callback.
     * @typeparam T The result's type.
     * @typeparam E The error's type.
     */
    function from<T, E = unknown>(op: Resolvable<T, E> | (() => Resolvable<T, E>)): Result<T, E>;
    /**
     * Creates a {@link Result} out of a promise or async callback.
     * @typeparam T The result's type.
     * @typeparam E The error's type.
     */
    function fromAsync<T, E = unknown>(op: Awaitable<Resolvable<T, E>> | (() => Awaitable<Resolvable<T, E>>)): Promise<Result<T, E>>;
    const err: typeof _err;
    const ok: typeof _ok;
    type Err<E> = import('./Result/Err').Err<E>;
    type Ok<T> = import('./Result/Ok').Ok<T>;
    type UnwrapOk<T extends Result<any, any>> = T extends Ok<infer S> ? S : never;
    type UnwrapErr<T extends Result<any, any>> = T extends Err<infer S> ? S : never;
}
//# sourceMappingURL=Result.d.ts.map