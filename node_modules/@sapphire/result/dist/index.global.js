"use strict";
var SapphireResult = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    Option: () => Option,
    OptionError: () => OptionError,
    Result: () => Result,
    ResultError: () => ResultError,
    err: () => err,
    none: () => none,
    ok: () => ok,
    some: () => some
  });

  // src/lib/common/utils.ts
  function isFunction(input) {
    return typeof input === "function";
  }
  __name(isFunction, "isFunction");

  // src/lib/Result/ResultError.ts
  var ResultError = class extends Error {
    constructor(message, value) {
      super(message);
      __publicField(this, "value");
      this.value = value;
    }
    get name() {
      return this.constructor.name;
    }
  };
  __name(ResultError, "ResultError");

  // src/lib/Result/Ok.ts
  var Ok = class {
    constructor(value) {
      __publicField(this, "value");
      this.value = value;
    }
    isOk() {
      return true;
    }
    isOkAnd(cb) {
      return cb(this.value);
    }
    isErr() {
      return false;
    }
    isErrAnd() {
      return false;
    }
    ok() {
      return some(this.value);
    }
    err() {
      return none;
    }
    map(cb) {
      return ok(cb(this.value));
    }
    mapInto(cb) {
      return cb(this.value);
    }
    mapOr(_, cb) {
      return cb(this.value);
    }
    mapOrElse(_, cb) {
      return cb(this.value);
    }
    mapErr() {
      return this;
    }
    mapErrInto() {
      return this;
    }
    inspect(cb) {
      cb(this.value);
      return this;
    }
    async inspectAsync(cb) {
      await cb(this.value);
      return this;
    }
    inspectErr() {
      return this;
    }
    inspectErrAsync() {
      return Promise.resolve(this);
    }
    *iter() {
      yield this.value;
    }
    expect() {
      return this.value;
    }
    expectErr(message) {
      throw new ResultError(message, this.value);
    }
    unwrap() {
      return this.value;
    }
    unwrapErr() {
      throw new ResultError("Unwrap failed", this.value);
    }
    unwrapOr() {
      return this.value;
    }
    unwrapOrElse() {
      return this.value;
    }
    and(result) {
      return result;
    }
    andThen(cb) {
      return cb(this.value);
    }
    or() {
      return this;
    }
    orElse() {
      return this;
    }
    contains(value) {
      return this.value === value;
    }
    containsErr() {
      return false;
    }
    transpose() {
      return this.value.match({
        some: (value) => some(ok(value)),
        none: () => none
      });
    }
    flatten() {
      return this.value;
    }
    intoOkOrErr() {
      return this.value;
    }
    async intoPromise() {
      return ok(await this.value);
    }
    eq(other) {
      return other.isOkAnd((value) => this.value === value);
    }
    ne(other) {
      return !this.eq(other);
    }
    match(branches) {
      return branches.ok(this.value);
    }
    *[Symbol.iterator]() {
      yield this.value;
    }
  };
  __name(Ok, "Ok");
  function ok(x) {
    return new Ok(x);
  }
  __name(ok, "ok");

  // src/lib/Option/Some.ts
  var Some = class {
    constructor(value) {
      __publicField(this, "value");
      this.value = value;
    }
    isSome() {
      return true;
    }
    isSomeAnd(cb) {
      return cb(this.value);
    }
    isNone() {
      return false;
    }
    expect() {
      return this.value;
    }
    unwrap() {
      return this.value;
    }
    unwrapOr() {
      return this.value;
    }
    unwrapOrElse() {
      return this.value;
    }
    map(cb) {
      return some(cb(this.value));
    }
    mapInto(cb) {
      return cb(this.value);
    }
    mapOr(_, cb) {
      return cb(this.value);
    }
    mapOrElse(_, cb) {
      return cb(this.value);
    }
    mapNoneInto() {
      return this;
    }
    inspect(cb) {
      cb(this.value);
      return this;
    }
    async inspectAsync(cb) {
      await cb(this.value);
      return this;
    }
    okOr() {
      return ok(this.value);
    }
    okOrElse() {
      return ok(this.value);
    }
    *iter() {
      yield this.value;
    }
    and(option) {
      return option;
    }
    andThen(cb) {
      return cb(this.value);
    }
    or() {
      return this;
    }
    orElse() {
      return this;
    }
    xor(option) {
      return option.isSome() ? none : this;
    }
    filter(predicate) {
      return predicate(this.value) ? this : none;
    }
    contains(value) {
      return this.value === value;
    }
    zip(other) {
      return other.map((o) => [this.value, o]);
    }
    zipWith(other, f) {
      return other.map((o) => f(this.value, o));
    }
    unzip() {
      const [s, o] = this.value;
      return [some(s), some(o)];
    }
    transpose() {
      return this.value.match({
        ok: (v) => ok(some(v)),
        err: (e) => err(e)
      });
    }
    flatten() {
      return this.value;
    }
    async intoPromise() {
      return some(await this.value);
    }
    eq(other) {
      return other.isSomeAnd((value) => this.value === value);
    }
    ne(other) {
      return !this.eq(other);
    }
    match(branches) {
      return branches.some(this.value);
    }
    *[Symbol.iterator]() {
      yield this.value;
    }
  };
  __name(Some, "Some");
  function some(value) {
    return new Some(value);
  }
  __name(some, "some");

  // src/lib/Result/Err.ts
  var Err = class {
    constructor(error) {
      __publicField(this, "error");
      this.error = error;
    }
    isOk() {
      return false;
    }
    isOkAnd() {
      return false;
    }
    isErr() {
      return true;
    }
    isErrAnd(cb) {
      return cb(this.error);
    }
    ok() {
      return none;
    }
    err() {
      return some(this.error);
    }
    map() {
      return this;
    }
    mapInto() {
      return this;
    }
    mapOr(defaultValue) {
      return defaultValue;
    }
    mapOrElse(op) {
      return op(this.error);
    }
    mapErr(cb) {
      return err(cb(this.error));
    }
    mapErrInto(cb) {
      return cb(this.error);
    }
    inspect() {
      return this;
    }
    inspectAsync() {
      return Promise.resolve(this);
    }
    inspectErr(cb) {
      cb(this.error);
      return this;
    }
    async inspectErrAsync(cb) {
      await cb(this.error);
      return this;
    }
    *iter() {
    }
    expect(message) {
      throw new ResultError(message, this.error);
    }
    expectErr() {
      return this.error;
    }
    unwrap() {
      throw new ResultError("Unwrap failed", this.error);
    }
    unwrapErr() {
      return this.error;
    }
    unwrapOr(defaultValue) {
      return defaultValue;
    }
    unwrapOrElse(op) {
      return op(this.error);
    }
    and() {
      return this;
    }
    andThen() {
      return this;
    }
    or(result) {
      return result;
    }
    orElse(cb) {
      return cb(this.error);
    }
    contains() {
      return false;
    }
    containsErr(error) {
      return this.error === error;
    }
    transpose() {
      return some(this);
    }
    flatten() {
      return this;
    }
    intoOkOrErr() {
      return this.error;
    }
    async intoPromise() {
      return err(await this.error);
    }
    eq(other) {
      return other.isErrAnd((error) => this.error === error);
    }
    ne(other) {
      return !this.eq(other);
    }
    match(branches) {
      return branches.err(this.error);
    }
    *[Symbol.iterator]() {
    }
  };
  __name(Err, "Err");
  function err(x) {
    return new Err(x);
  }
  __name(err, "err");

  // src/lib/Option/OptionError.ts
  var OptionError = class extends Error {
    get name() {
      return this.constructor.name;
    }
  };
  __name(OptionError, "OptionError");

  // src/lib/Option/None.ts
  var None = class {
    isSome() {
      return false;
    }
    isSomeAnd() {
      return false;
    }
    isNone() {
      return true;
    }
    expect(message) {
      throw new OptionError(message);
    }
    unwrap() {
      throw new OptionError("Unwrap failed");
    }
    unwrapOr(defaultValue) {
      return defaultValue;
    }
    unwrapOrElse(cb) {
      return cb();
    }
    map() {
      return this;
    }
    mapInto() {
      return this;
    }
    mapOr(defaultValue) {
      return defaultValue;
    }
    mapOrElse(defaultValue) {
      return defaultValue();
    }
    mapNoneInto(cb) {
      return cb();
    }
    inspect() {
      return this;
    }
    inspectAsync() {
      return Promise.resolve(this);
    }
    okOr(error) {
      return err(error);
    }
    okOrElse(cb) {
      return err(cb());
    }
    *iter() {
    }
    and() {
      return this;
    }
    andThen() {
      return this;
    }
    or(option) {
      return option;
    }
    orElse(cb) {
      return cb();
    }
    xor(option) {
      return option.isSome() ? option : this;
    }
    filter() {
      return this;
    }
    contains() {
      return false;
    }
    zip() {
      return this;
    }
    zipWith() {
      return this;
    }
    unzip() {
      return [this, this];
    }
    transpose() {
      return ok(this);
    }
    flatten() {
      return this;
    }
    intoPromise() {
      return Promise.resolve(none);
    }
    eq(other) {
      return other.isNone();
    }
    ne(other) {
      return other.isSome();
    }
    match(branches) {
      return branches.none();
    }
    *[Symbol.iterator]() {
    }
  };
  __name(None, "None");
  var none = new None();

  // src/lib/Option.ts
  var Option;
  ((Option2) => {
    function resolve(value) {
      if (value === null || value === void 0)
        return Option2.none;
      if (is(value))
        return value;
      return Option2.some(value);
    }
    __name(resolve, "resolve");
    function is(value) {
      return value instanceof None || value instanceof Some;
    }
    Option2.is = is;
    __name(is, "is");
    function from(op) {
      if (!isFunction(op))
        return resolve(op);
      try {
        return resolve(op());
      } catch {
        return Option2.none;
      }
    }
    Option2.from = from;
    __name(from, "from");
    async function fromAsync(op) {
      try {
        return resolve(await (isFunction(op) ? op() : op));
      } catch {
        return Option2.none;
      }
    }
    Option2.fromAsync = fromAsync;
    __name(fromAsync, "fromAsync");
    Option2.none = none;
    Option2.some = some;
  })(Option || (Option = {}));

  // src/lib/Result.ts
  var Result;
  ((Result2) => {
    function resolve(value) {
      if (is(value))
        return value;
      return Result2.ok(value);
    }
    __name(resolve, "resolve");
    function is(value) {
      return value instanceof Ok || value instanceof Err;
    }
    Result2.is = is;
    __name(is, "is");
    function from(op) {
      if (!isFunction(op))
        return resolve(op);
      try {
        return resolve(op());
      } catch (error) {
        return Result2.err(error);
      }
    }
    Result2.from = from;
    __name(from, "from");
    async function fromAsync(op) {
      try {
        return resolve(await (isFunction(op) ? op() : op));
      } catch (error) {
        return Result2.err(error);
      }
    }
    Result2.fromAsync = fromAsync;
    __name(fromAsync, "fromAsync");
    Result2.err = err;
    Result2.ok = ok;
  })(Result || (Result = {}));
  return __toCommonJS(src_exports);
})();
//# sourceMappingURL=index.global.js.map