{"version":3,"sources":["../src/index.ts","../../result/src/lib/common/utils.ts","../../result/src/lib/Result/ResultError.ts","../../result/src/lib/Result/Ok.ts","../../result/src/lib/Option/Some.ts","../../result/src/lib/Result/Err.ts","../../result/src/lib/Option/OptionError.ts","../../result/src/lib/Option/None.ts","../../result/src/lib/Option.ts","../../result/src/lib/Result.ts","../src/lib/ArgumentStream.ts","../src/lib/lexer/streams/parameters/BaseParameter.ts","../src/lib/lexer/streams/parameters/QuotedParameter.ts","../src/lib/lexer/streams/parameters/WordParameter.ts","../src/lib/lexer/streams/raw/TokenStream.ts","../src/lib/lexer/streams/ParameterStream.ts","../src/lib/lexer/Lexer.ts","../src/lib/parser/ParserResult.ts","../src/lib/parser/strategies/EmptyStrategy.ts","../src/lib/parser/Parser.ts","../src/lib/parser/strategies/PrefixedStrategy.ts","../src/lib/util/util.ts"],"sourcesContent":["export * from './lib/ArgumentStream';\nexport * from './lib/lexer/Lexer';\nexport * from './lib/lexer/streams/parameters/BaseParameter';\nexport * from './lib/lexer/streams/parameters/QuotedParameter';\nexport * from './lib/lexer/streams/parameters/WordParameter';\nexport * from './lib/lexer/streams/ParameterStream';\nexport * from './lib/lexer/streams/raw/TokenStream';\nexport * from './lib/parser/Parser';\nexport * from './lib/parser/ParserResult';\nexport * from './lib/parser/strategies/EmptyStrategy';\nexport * from './lib/parser/strategies/IUnorderedStrategy';\nexport * from './lib/parser/strategies/PrefixedStrategy';\nexport * from './lib/util/util';\n","export type Awaitable<T> = PromiseLike<T> | T;\n\nexport function isFunction<A extends readonly any[], R>(cb: (...args: A) => R): true;\nexport function isFunction(input: any): input is (...args: readonly any[]) => any;\nexport function isFunction(input: any) {\n\treturn typeof input === 'function';\n}\n\nexport function isPromise<T>(input: PromiseLike<T>): true;\nexport function isPromise(input: any): input is PromiseLike<any>;\nexport function isPromise(input: any) {\n\treturn typeof input === 'object' && input !== null && typeof input.then === 'function';\n}\n","export class ResultError<E> extends Error {\n\tpublic readonly value: E;\n\n\tpublic constructor(message: string, value: E) {\n\t\tsuper(message);\n\t\tthis.value = value;\n\t}\n\n\tpublic override get name(): string {\n\t\treturn this.constructor.name;\n\t}\n}\n","import type { Awaitable } from '../common/utils';\nimport type { Option } from '../Option';\nimport { none, type None } from '../Option/None';\nimport { some, type Some } from '../Option/Some';\nimport type { Result } from '../Result';\nimport type { Err } from './Err';\nimport type { IResult } from './IResult';\nimport { ResultError } from './ResultError';\n\nexport class Ok<T> implements IResult<T, any> {\n\tprivate readonly value: T;\n\n\tpublic constructor(value: T) {\n\t\tthis.value = value;\n\t}\n\n\tpublic isOk(): this is Ok<T> {\n\t\treturn true;\n\t}\n\n\tpublic isOkAnd<R extends boolean>(cb: (value: T) => R): R {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic isErr(): false {\n\t\treturn false;\n\t}\n\n\tpublic isErrAnd(cb?: (error: never) => boolean): false;\n\tpublic isErrAnd(): false {\n\t\treturn false;\n\t}\n\n\tpublic ok(): Some<T> {\n\t\treturn some(this.value);\n\t}\n\n\tpublic err(): None {\n\t\treturn none;\n\t}\n\n\tpublic map<U>(cb: (value: T) => U): Ok<U> {\n\t\treturn ok(cb(this.value));\n\t}\n\n\tpublic mapInto<R extends Result<any, any>>(cb: (value: T) => R): R {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic mapOr<U>(_: U, cb: (value: T) => U): U {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic mapOrElse<U>(_: (error: never) => U, cb: (value: T) => U): U {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic mapErr(cb?: (error: never) => any): this;\n\tpublic mapErr(): this {\n\t\treturn this;\n\t}\n\n\tpublic mapErrInto(cb: (error: never) => Result<any, any>): this;\n\tpublic mapErrInto(): this {\n\t\treturn this;\n\t}\n\n\tpublic inspect(cb: (value: T) => void): this {\n\t\tcb(this.value);\n\t\treturn this;\n\t}\n\n\tpublic async inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this> {\n\t\tawait cb(this.value);\n\t\treturn this;\n\t}\n\n\tpublic inspectErr(cb?: (error: never) => void): this;\n\tpublic inspectErr(): this {\n\t\treturn this;\n\t}\n\n\tpublic inspectErrAsync(cb?: (error: never) => Awaitable<unknown>): Promise<this>;\n\tpublic inspectErrAsync(): Promise<this> {\n\t\treturn Promise.resolve(this);\n\t}\n\n\tpublic *iter(): Generator<T> {\n\t\tyield this.value;\n\t}\n\n\tpublic expect(message?: string): T;\n\tpublic expect(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic expectErr(message: string): never {\n\t\tthrow new ResultError(message, this.value);\n\t}\n\n\tpublic unwrap(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic unwrapErr(): never {\n\t\tthrow new ResultError('Unwrap failed', this.value);\n\t}\n\n\tpublic unwrapOr(defaultValue: unknown): T;\n\tpublic unwrapOr(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic unwrapOrElse(op: (error: any) => unknown): T;\n\tpublic unwrapOrElse(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic and<R extends Result<any, any>>(result: R): R {\n\t\treturn result;\n\t}\n\n\tpublic andThen<R extends Result<any, any>>(cb: (value: T) => R): R {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic or(result: Result<T, any>): this;\n\tpublic or(): this {\n\t\treturn this;\n\t}\n\n\tpublic orElse(cb: (error: never) => Result<T, any>): this;\n\tpublic orElse(): this {\n\t\treturn this;\n\t}\n\n\tpublic contains(value: T): boolean {\n\t\treturn this.value === value;\n\t}\n\n\tpublic containsErr(error?: unknown): false;\n\tpublic containsErr(): false {\n\t\treturn false;\n\t}\n\n\tpublic transpose(this: Ok<None>): None;\n\tpublic transpose<Inner>(this: Ok<Some<Inner>>): Some<Ok<Inner>>;\n\tpublic transpose<Inner>(this: Ok<Option<Inner>>): Option<Ok<Inner>>;\n\tpublic transpose<IT>(this: Ok<Option<IT>>): Option<Ok<IT>> {\n\t\treturn this.value.match({\n\t\t\tsome: (value) => some(ok(value)),\n\t\t\tnone: () => none\n\t\t});\n\t}\n\n\tpublic flatten<Inner extends Result<any, any>>(this: Ok<Inner>): Inner {\n\t\treturn this.value;\n\t}\n\n\tpublic intoOkOrErr() {\n\t\treturn this.value;\n\t}\n\n\tpublic async intoPromise(): Promise<Ok<Awaited<T>>> {\n\t\treturn ok(await this.value);\n\t}\n\n\tpublic eq(other: Err<any>): false;\n\tpublic eq(other: Result<T, any>): boolean;\n\tpublic eq(other: Result<T, any>): boolean {\n\t\treturn other.isOkAnd((value) => this.value === value);\n\t}\n\n\tpublic ne(other: Err<any>): true;\n\tpublic ne(other: Result<T, any>): boolean;\n\tpublic ne(other: Result<T, any>): boolean {\n\t\treturn !this.eq(other);\n\t}\n\n\tpublic match<OkValue, ErrValue>(branches: { ok(value: T): OkValue; err(error: never): ErrValue }): OkValue {\n\t\treturn branches.ok(this.value);\n\t}\n\n\tpublic *[Symbol.iterator](): Generator<T> {\n\t\tyield this.value;\n\t}\n}\n\n/**\n * Creates an Ok with no value.\n * @return A successful Result.\n */\nexport function ok(): Ok<unknown>;\n\n/**\n * Creates an Ok.\n * @typeparam T The result's type.\n * @param x Value to use.\n * @return A successful Result.\n */\nexport function ok<T>(x: T): Ok<T>;\nexport function ok<T>(x?: T): Ok<T | undefined> {\n\treturn new Ok(x);\n}\n","import type { Awaitable } from '../common/utils';\nimport type { Option } from '../Option';\nimport type { Result } from '../Result';\nimport { err, type Err } from '../Result/Err';\nimport { ok, type Ok } from '../Result/Ok';\nimport type { IOption } from './IOption';\nimport { none, type None } from './None';\n\nexport class Some<T> implements IOption<T> {\n\tprivate readonly value: T;\n\n\tpublic constructor(value: T) {\n\t\tthis.value = value;\n\t}\n\n\tpublic isSome(): this is Some<T> {\n\t\treturn true;\n\t}\n\n\tpublic isSomeAnd<R extends boolean>(cb: (value: T) => R): R {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic isNone(): false {\n\t\treturn false;\n\t}\n\n\tpublic expect(message: string): T;\n\tpublic expect(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic unwrap(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic unwrapOr(defaultValue: unknown): T;\n\tpublic unwrapOr(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic unwrapOrElse(cb: () => unknown): T;\n\tpublic unwrapOrElse(): T {\n\t\treturn this.value;\n\t}\n\n\tpublic map<U>(cb: (value: T) => U): Some<U> {\n\t\treturn some(cb(this.value));\n\t}\n\n\tpublic mapInto<R extends Option<any>>(cb: (value: T) => R): R {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic mapOr<U>(_: U, cb: (value: T) => U): U {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic mapOrElse<U>(_: () => U, cb: (value: T) => U): U {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic mapNoneInto(cb: () => Option<any>): this;\n\tpublic mapNoneInto(): this {\n\t\treturn this;\n\t}\n\n\tpublic inspect(cb: (value: T) => void): this {\n\t\tcb(this.value);\n\t\treturn this;\n\t}\n\n\tpublic async inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this> {\n\t\tawait cb(this.value);\n\t\treturn this;\n\t}\n\n\tpublic okOr(err?: any): Ok<T>;\n\tpublic okOr(): Ok<T> {\n\t\treturn ok(this.value);\n\t}\n\n\tpublic okOrElse(cb: () => any): Ok<T>;\n\tpublic okOrElse(): Ok<T> {\n\t\treturn ok(this.value);\n\t}\n\n\tpublic *iter(): Generator<T> {\n\t\tyield this.value;\n\t}\n\n\tpublic and<R extends Option<any>>(option: R): R {\n\t\treturn option;\n\t}\n\n\tpublic andThen<R extends Option<any>>(cb: (value: T) => R): R {\n\t\treturn cb(this.value);\n\t}\n\n\tpublic or(option: Option<any>): this;\n\tpublic or(): this {\n\t\treturn this;\n\t}\n\n\tpublic orElse(cb?: () => Option<any>): this;\n\tpublic orElse(): this {\n\t\treturn this;\n\t}\n\n\tpublic xor(option: Some<T>): None;\n\tpublic xor(option: None): this;\n\tpublic xor(option: Option<T>): this | None;\n\tpublic xor(option: Option<T>): this | None {\n\t\treturn option.isSome() ? none : this;\n\t}\n\n\tpublic filter(predicate: (value: T) => true): this;\n\tpublic filter(predicate: (value: T) => false): None;\n\tpublic filter(predicate: (value: T) => boolean): this | None;\n\tpublic filter(predicate: (value: T) => boolean): this | None {\n\t\treturn predicate(this.value) ? this : none;\n\t}\n\n\tpublic contains(value: T): boolean {\n\t\treturn this.value === value;\n\t}\n\n\tpublic zip(other: None): None;\n\tpublic zip<U>(other: Some<U>): Some<[T, U]>;\n\tpublic zip<U>(other: Option<U>): Option<[T, U]>;\n\tpublic zip<U>(other: Option<U>): Option<[T, U]> {\n\t\treturn other.map((o) => [this.value, o] as [T, U]);\n\t}\n\n\tpublic zipWith<U, R>(other: None, f: (s: T, o: U) => R): None;\n\tpublic zipWith<U, R>(other: Some<U>, f: (s: T, o: U) => R): Some<R>;\n\tpublic zipWith<U, R>(other: Option<U>, f: (s: T, o: U) => R): Option<R>;\n\tpublic zipWith<U, R>(other: Option<U>, f: (s: T, o: U) => R): Option<R> {\n\t\treturn other.map((o) => f(this.value, o));\n\t}\n\n\tpublic unzip<I, U>(this: Some<readonly [I, U]>): [Some<I>, Some<U>] {\n\t\tconst [s, o] = this.value;\n\t\treturn [some(s), some(o)];\n\t}\n\n\tpublic transpose<Inner>(this: Some<Ok<Inner>>): Ok<Some<Inner>>;\n\tpublic transpose<Inner>(this: Some<Err<Inner>>): Err<Some<Inner>>;\n\tpublic transpose<IT, E>(this: Some<Result<IT, E>>): Result<Some<IT>, E>;\n\tpublic transpose<IT, E>(this: Some<Result<IT, E>>): Result<Some<IT>, E> {\n\t\treturn this.value.match({\n\t\t\tok: (v) => ok(some(v)),\n\t\t\terr: (e) => err(e)\n\t\t});\n\t}\n\n\tpublic flatten<Inner extends Option<any>>(this: Some<Inner>): Inner {\n\t\treturn this.value;\n\t}\n\n\tpublic async intoPromise(): Promise<Some<Awaited<T>>> {\n\t\treturn some(await this.value);\n\t}\n\n\tpublic eq(other: None): false;\n\tpublic eq(other: Option<T>): boolean;\n\tpublic eq(other: Option<T>): boolean {\n\t\treturn other.isSomeAnd((value) => this.value === value);\n\t}\n\n\tpublic ne(other: None): true;\n\tpublic ne(other: Option<T>): boolean;\n\tpublic ne(other: Option<T>): boolean {\n\t\treturn !this.eq(other);\n\t}\n\n\tpublic match<SomeValue, NoneValue>(branches: { some(value: T): SomeValue; none(): NoneValue }): SomeValue {\n\t\treturn branches.some(this.value);\n\t}\n\n\tpublic *[Symbol.iterator](): Generator<T> {\n\t\tyield this.value;\n\t}\n}\n\nexport function some<T>(value: T): Some<T> {\n\treturn new Some<T>(value);\n}\n","import type { Awaitable } from '../common/utils';\nimport { none, type None } from '../Option/None';\nimport { some, type Some } from '../Option/Some';\nimport type { Result } from '../Result';\nimport type { IResult } from './IResult';\nimport type { Ok } from './Ok';\nimport { ResultError } from './ResultError';\n\nexport class Err<E> implements IResult<any, E> {\n\tprivate readonly error: E;\n\n\tpublic constructor(error: E) {\n\t\tthis.error = error;\n\t}\n\n\tpublic isOk(): false {\n\t\treturn false;\n\t}\n\n\tpublic isOkAnd(cb?: (value: never) => boolean): false;\n\tpublic isOkAnd(): false {\n\t\treturn false;\n\t}\n\n\tpublic isErr(): this is Err<E> {\n\t\treturn true;\n\t}\n\n\tpublic isErrAnd(cb: (error: E) => boolean): boolean {\n\t\treturn cb(this.error);\n\t}\n\n\tpublic ok(): None {\n\t\treturn none;\n\t}\n\n\tpublic err(): Some<E> {\n\t\treturn some(this.error);\n\t}\n\n\tpublic map(cb?: (value: never) => unknown): this;\n\tpublic map(): this {\n\t\treturn this;\n\t}\n\n\tpublic mapInto(cb: (value: never) => Result<any, any>): this;\n\tpublic mapInto(): this {\n\t\treturn this;\n\t}\n\n\tpublic mapOr<U>(defaultValue: U, cb?: (value: never) => U): U;\n\tpublic mapOr<U>(defaultValue: U): U {\n\t\treturn defaultValue;\n\t}\n\n\tpublic mapOrElse<U>(op: (error: E) => U, cb?: (value: never) => U): U;\n\tpublic mapOrElse<U>(op: (error: E) => U): U {\n\t\treturn op(this.error);\n\t}\n\n\tpublic mapErr<F>(cb: (error: E) => F): Err<F> {\n\t\treturn err(cb(this.error));\n\t}\n\n\tpublic mapErrInto<R extends Result<any, any>>(cb: (error: E) => R): R {\n\t\treturn cb(this.error);\n\t}\n\n\tpublic inspect(cb?: (value: never) => void): this;\n\tpublic inspect(): this {\n\t\treturn this;\n\t}\n\n\tpublic inspectAsync(cb?: (value: never) => Awaitable<unknown>): Promise<this>;\n\tpublic inspectAsync(): Promise<this> {\n\t\treturn Promise.resolve(this);\n\t}\n\n\tpublic inspectErr(cb: (error: E) => void): this {\n\t\tcb(this.error);\n\t\treturn this;\n\t}\n\n\tpublic async inspectErrAsync(cb: (error: E) => Awaitable<unknown>): Promise<this> {\n\t\tawait cb(this.error);\n\t\treturn this;\n\t}\n\n\tpublic *iter(): Generator<never> {\n\t\t// Yields no values\n\t}\n\n\tpublic expect(message: string): never {\n\t\tthrow new ResultError(message, this.error);\n\t}\n\n\tpublic expectErr(message?: string): E;\n\tpublic expectErr(): E {\n\t\treturn this.error;\n\t}\n\n\tpublic unwrap(): never {\n\t\tthrow new ResultError('Unwrap failed', this.error);\n\t}\n\n\tpublic unwrapErr(): E {\n\t\treturn this.error;\n\t}\n\n\tpublic unwrapOr<T>(defaultValue: T): T {\n\t\treturn defaultValue;\n\t}\n\n\tpublic unwrapOrElse<T>(op: (error: E) => T): T {\n\t\treturn op(this.error);\n\t}\n\n\tpublic and(result?: Result<any, E>): this;\n\tpublic and(): this {\n\t\treturn this;\n\t}\n\n\tpublic andThen(cb?: (value: never) => Result<any, E>): this;\n\tpublic andThen(): this {\n\t\treturn this;\n\t}\n\n\tpublic or<R extends Result<any, any>>(result: R): R {\n\t\treturn result;\n\t}\n\n\tpublic orElse<R extends Result<any, any>>(cb: (error: E) => R): R {\n\t\treturn cb(this.error);\n\t}\n\n\tpublic contains(value?: any): false;\n\tpublic contains(): false {\n\t\treturn false;\n\t}\n\n\tpublic containsErr(error: E): boolean {\n\t\treturn this.error === error;\n\t}\n\n\tpublic transpose(): Some<this> {\n\t\treturn some(this);\n\t}\n\n\tpublic flatten(): this {\n\t\treturn this;\n\t}\n\n\tpublic intoOkOrErr(): E {\n\t\treturn this.error;\n\t}\n\n\tpublic async intoPromise(): Promise<Err<Awaited<E>>> {\n\t\treturn err(await this.error);\n\t}\n\n\tpublic eq(other: Ok<any>): false;\n\tpublic eq(other: Result<any, E>): boolean;\n\tpublic eq(other: Result<any, E>): boolean {\n\t\treturn other.isErrAnd((error) => this.error === error);\n\t}\n\n\tpublic ne(other: Ok<any>): true;\n\tpublic ne(other: Result<any, E>): boolean;\n\tpublic ne(other: Result<any, E>): boolean {\n\t\treturn !this.eq(other);\n\t}\n\n\tpublic match<OkValue, ErrValue>(branches: { ok(value: never): OkValue; err(error: E): ErrValue }): ErrValue {\n\t\treturn branches.err(this.error);\n\t}\n\n\tpublic *[Symbol.iterator](): Generator<never> {\n\t\t// Yields no values\n\t}\n}\n\n/**\n * Creates an Err with no error.\n * @return An erroneous Result.\n */\nexport function err(): Err<unknown>;\n\n/**\n * Creates an Err.\n * @typeparam E The error's type.\n * @param x Value to use.\n * @return An erroneous Result.\n */\nexport function err<E>(x: E): Err<E>;\nexport function err<E>(x?: E): Err<unknown> {\n\treturn new Err(x);\n}\n","export class OptionError extends Error {\n\tpublic override get name(): string {\n\t\treturn this.constructor.name;\n\t}\n}\n","import type { Awaitable } from '../common/utils';\nimport type { Option } from '../Option';\nimport { err, type Err } from '../Result/Err';\nimport { ok, type Ok } from '../Result/Ok';\nimport type { IOption } from './IOption';\nimport { OptionError } from './OptionError';\nimport type { Some } from './Some';\n\nexport class None implements IOption<any> {\n\tpublic isSome(): false {\n\t\treturn false;\n\t}\n\n\tpublic isSomeAnd(cb?: (value: never) => boolean): false;\n\tpublic isSomeAnd(): false {\n\t\treturn false;\n\t}\n\n\tpublic isNone(): this is None {\n\t\treturn true;\n\t}\n\n\tpublic expect(message: string): never {\n\t\tthrow new OptionError(message);\n\t}\n\n\tpublic unwrap(): never {\n\t\tthrow new OptionError('Unwrap failed');\n\t}\n\n\tpublic unwrapOr<R>(defaultValue: R): R {\n\t\treturn defaultValue;\n\t}\n\n\tpublic unwrapOrElse<R>(cb: () => R): R {\n\t\treturn cb();\n\t}\n\n\tpublic map(cb: (value: never) => any): this;\n\tpublic map(): this {\n\t\treturn this;\n\t}\n\n\tpublic mapInto(cb: (value: never) => Option<any>): this;\n\tpublic mapInto(): this {\n\t\treturn this;\n\t}\n\n\tpublic mapOr<R>(defaultValue: R, cb?: (value: never) => R): R;\n\tpublic mapOr<R>(defaultValue: R): R {\n\t\treturn defaultValue;\n\t}\n\n\tpublic mapOrElse<R>(defaultValue: () => R, cb?: (value: never) => R): R;\n\tpublic mapOrElse<R>(defaultValue: () => R): R {\n\t\treturn defaultValue();\n\t}\n\n\tpublic mapNoneInto<R extends Option<any>>(cb: () => R): R {\n\t\treturn cb();\n\t}\n\n\tpublic inspect(cb?: (value: never) => void): this;\n\tpublic inspect(): this {\n\t\treturn this;\n\t}\n\n\tpublic inspectAsync(cb?: (value: never) => Awaitable<unknown>): Promise<this>;\n\tpublic inspectAsync(): Promise<this> {\n\t\treturn Promise.resolve(this);\n\t}\n\n\tpublic okOr<E>(error: E): Err<E> {\n\t\treturn err(error);\n\t}\n\n\tpublic okOrElse<E>(cb: () => E): Err<E> {\n\t\treturn err(cb());\n\t}\n\n\tpublic *iter(): Generator<never> {\n\t\t// Yields no values\n\t}\n\n\tpublic and(option: Option<any>): this;\n\tpublic and(): this {\n\t\treturn this;\n\t}\n\n\tpublic andThen(cb: (value: never) => Option<any>): this;\n\tpublic andThen(): this {\n\t\treturn this;\n\t}\n\n\tpublic or<R extends Option<any>>(option: R): R {\n\t\treturn option;\n\t}\n\n\tpublic orElse<R extends Option<any>>(cb: () => R): R {\n\t\treturn cb();\n\t}\n\n\tpublic xor<T>(option: None): None;\n\tpublic xor<T>(option: Some<T>): Some<T>;\n\tpublic xor<T>(option: Option<T>): Some<T> | None;\n\tpublic xor<T>(option: Some<T> | None): Some<T> | None {\n\t\treturn option.isSome() ? option : this;\n\t}\n\n\tpublic filter(predicate: (value: never) => boolean): None;\n\tpublic filter(): None {\n\t\treturn this;\n\t}\n\n\tpublic contains(value?: any): false;\n\tpublic contains(): false {\n\t\treturn false;\n\t}\n\n\tpublic zip(other: Option<any>): None;\n\tpublic zip(): None {\n\t\treturn this;\n\t}\n\n\tpublic zipWith(other: Option<any>, f: (s: never, o: never) => any): None;\n\tpublic zipWith(): None {\n\t\treturn this;\n\t}\n\n\tpublic unzip(): [None, None] {\n\t\treturn [this, this];\n\t}\n\n\tpublic transpose(): Ok<None> {\n\t\treturn ok(this);\n\t}\n\n\tpublic flatten(): None {\n\t\treturn this;\n\t}\n\n\tpublic intoPromise(): Promise<None> {\n\t\treturn Promise.resolve(none);\n\t}\n\n\tpublic eq(other: None): true;\n\tpublic eq(other: Some<any>): false;\n\tpublic eq(other: Option<any>): boolean;\n\tpublic eq(other: Option<any>): boolean {\n\t\treturn other.isNone();\n\t}\n\n\tpublic ne(other: None): false;\n\tpublic ne(other: Some<any>): true;\n\tpublic ne(other: Option<any>): boolean;\n\tpublic ne(other: Option<any>): boolean {\n\t\treturn other.isSome();\n\t}\n\n\tpublic match<SomeValue, NoneValue>(branches: { some(value: never): SomeValue; none(): NoneValue }): NoneValue {\n\t\treturn branches.none();\n\t}\n\n\tpublic *[Symbol.iterator](): Generator<never> {\n\t\t// Yields no values\n\t}\n}\n\nexport const none = new None();\n","import { Awaitable, isFunction } from './common/utils';\nimport { None, none as _none } from './Option/None';\nimport { Some, some as _some } from './Option/Some';\n\nexport * from './Option/IOption';\nexport * from './Option/OptionError';\nexport { _some as some, _none as none };\n\n/**\n * The union of the two variations of `Option`.\n * @typeparam T The value's type.\n */\nexport type Option<T> = Option.Some<T> | Option.None;\n\nexport namespace Option {\n\texport type Resolvable<T> = T | null | undefined | Option<T>;\n\tfunction resolve<T>(value: Resolvable<T>) {\n\t\tif (value === null || value === undefined) return none;\n\t\tif (is(value)) return value;\n\t\treturn some(value);\n\t}\n\n\texport function is<T>(value: Option<T>): true;\n\texport function is(value: any): value is Option<unknown>;\n\texport function is(value: any) {\n\t\treturn value instanceof None || value instanceof Some;\n\t}\n\n\t/**\n\t * Creates an {@link Option} out of a value or callback.\n\t * @typeparam T The result's type.\n\t */\n\texport function from<T>(op: Resolvable<T> | (() => Resolvable<T>)): Option<T> {\n\t\tif (!isFunction(op)) return resolve(op);\n\n\t\ttry {\n\t\t\treturn resolve(op());\n\t\t} catch {\n\t\t\treturn none;\n\t\t}\n\t}\n\n\t/**\n\t * Creates an {@link Option} out of a value or callback.\n\t * @typeparam T The result's type.\n\t */\n\texport async function fromAsync<T>(op: Awaitable<Resolvable<T>> | (() => Awaitable<Resolvable<T>>)): Promise<Option<T>> {\n\t\ttry {\n\t\t\treturn resolve(await (isFunction(op) ? op() : op));\n\t\t} catch {\n\t\t\treturn none;\n\t\t}\n\t}\n\n\texport const none = _none;\n\texport const some = _some;\n\n\texport type Some<T> = import('./Option/Some').Some<T>;\n\texport type None = import('./Option/None').None;\n\n\texport type UnwrapSome<T extends Option<any>> = T extends Some<infer S> ? S : never;\n}\n","import { isFunction, type Awaitable } from './common/utils';\nimport { Err, err as _err } from './Result/Err';\nimport { Ok, ok as _ok } from './Result/Ok';\n\nexport * from './Result/IResult';\nexport * from './Result/ResultError';\nexport { _ok as ok, _err as err };\n\n/**\n * The union of the two variations of `Result`.\n * @typeparam T The result's type.\n * @typeparam E The error's type.\n */\nexport type Result<T, E> = Result.Ok<T> | Result.Err<E>;\n\nexport namespace Result {\n\texport type Resolvable<T, E> = T | Result<T, E>;\n\tfunction resolve<T, E>(value: Resolvable<T, E>) {\n\t\tif (is(value)) return value;\n\t\treturn ok(value);\n\t}\n\n\texport function is<T, E>(value: Result<T, E>): true;\n\texport function is(value: any): value is Result<unknown, unknown>;\n\texport function is(value: any) {\n\t\treturn value instanceof Ok || value instanceof Err;\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a callback.\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\texport function from<T, E = unknown>(op: Resolvable<T, E> | (() => Resolvable<T, E>)): Result<T, E> {\n\t\tif (!isFunction(op)) return resolve(op);\n\n\t\ttry {\n\t\t\treturn resolve(op());\n\t\t} catch (error) {\n\t\t\treturn err(error as E);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a promise or async callback.\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\texport async function fromAsync<T, E = unknown>(op: Awaitable<Resolvable<T, E>> | (() => Awaitable<Resolvable<T, E>>)): Promise<Result<T, E>> {\n\t\ttry {\n\t\t\treturn resolve(await (isFunction(op) ? op() : op));\n\t\t} catch (error) {\n\t\t\treturn err(error as E);\n\t\t}\n\t}\n\n\texport const err = _err;\n\texport const ok = _ok;\n\n\texport type Err<E> = import('./Result/Err').Err<E>;\n\texport type Ok<T> = import('./Result/Ok').Ok<T>;\n\n\texport type UnwrapOk<T extends Result<any, any>> = T extends Ok<infer S> ? S : never;\n\texport type UnwrapErr<T extends Result<any, any>> = T extends Err<infer S> ? S : never;\n}\n","import { Option, Result } from '@sapphire/result';\nimport type { Parameter } from './lexer/streams/ParameterStream';\nimport type { ParserResult } from './parser/ParserResult';\n\nexport class ArgumentStream {\n\tpublic readonly results: ParserResult;\n\tpublic state: ArgumentStream.State;\n\n\tpublic constructor(results: ParserResult) {\n\t\tthis.results = results;\n\t\tthis.state = { used: new Set(), position: 0 };\n\t}\n\n\t/**\n\t * Whether or not all ordered parameters were used.\n\t */\n\tpublic get finished() {\n\t\treturn this.used === this.length;\n\t}\n\n\t/**\n\t * The amount of ordered parameters.\n\t */\n\tpublic get length() {\n\t\treturn this.results.ordered.length;\n\t}\n\n\t/**\n\t * The remaining amount of ordered parameters.\n\t */\n\tpublic get remaining() {\n\t\treturn this.length - this.used;\n\t}\n\n\t/**\n\t * The amount of ordered parameters that have been used.\n\t */\n\tpublic get used() {\n\t\treturn this.state.used.size;\n\t}\n\n\t/**\n\t * Retrieves the value of the next unused ordered token.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(args.single());\n\t * // Ok { value: '1' }\n\t *\n\t * console.log(args.single());\n\t * // Ok { value: '2' }\n\t *\n\t * console.log(args.single());\n\t * // Ok { value: '3' }\n\t *\n\t * console.log(args.single());\n\t * // None\n\t * ```\n\t *\n\t * @returns The value, if any.\n\t */\n\tpublic single(): Option<string> {\n\t\tif (this.finished) return Option.none;\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tthis.state.used.add(this.state.position);\n\t\treturn Option.some(this.results.ordered[this.state.position++].value);\n\t}\n\n\t/**\n\t * Retrieves the value of the next unused ordered token, but only if it could be transformed.\n\t *\n\t * @note This does not support asynchronous results, refer to {@link singleMapAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * const parse = (value) => {\n\t *   const number = Number(value);\n\t *   return Number.isNaN(number) ? Option.none : Option.some(number);\n\t * };\n\t *\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(args.singleMap(parse));\n\t * // Some { value: 1 }\n\t *\n\t * console.log(args.singleMap(parse));\n\t * // Some { value: 2 }\n\t *\n\t * console.log(args.singleMap(parse));\n\t * // Some { value: 3 }\n\t *\n\t * console.log(args.singleMap(parse));\n\t * // None\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.\n\t * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.\n\t * @returns The mapped value, if any.\n\t */\n\tpublic singleMap<T>(predicate: (value: string) => Option<T>, useAnyways = false): Option<T> {\n\t\tif (this.finished) return Option.none;\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tconst result = predicate(this.results.ordered[this.state.position].value);\n\t\tif (result.isSome() || useAnyways) {\n\t\t\tthis.state.used.add(this.state.position);\n\t\t\t++this.state.position;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Retrieves the value of the next unused ordered token, but only if it could be transformed.\n\t *\n\t * @note This is an asynchronous variant of {@link singleMap}.\n\t *\n\t * @typeparam T The output type.\n\t * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.\n\t * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.\n\t * @returns The mapped value, if any.\n\t */\n\tpublic async singleMapAsync<T>(predicate: (value: string) => Promise<Option<T>>, useAnyways = false): Promise<Option<T>> {\n\t\tif (this.finished) return Option.none;\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tconst result = await predicate(this.results.ordered[this.state.position].value);\n\t\tif (result.isSome() || useAnyways) {\n\t\t\tthis.state.used.add(this.state.position);\n\t\t\t++this.state.position;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Finds and retrieves the next unused parameter and transforms it.\n\t *\n\t * @note This is a variant of {@link findMap} that returns the errors on failure.\n\t * @note This does not support asynchronous results, refer to {@link singleParseAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * const parse = (value) => {\n\t *   const number = Number(value);\n\t *   return Number.isNaN(number)\n\t *     ? Result.err(`Could not parse ${value} to a number`)\n\t *     : Result.ok(number);\n\t * };\n\t *\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(args.singleParse(parse));\n\t * // Ok { value: 1 }\n\t *\n\t * console.log(args.singleParse(parse));\n\t * // Ok { value: 2 }\n\t *\n\t * console.log(args.singleParse(parse));\n\t * // Ok { value: 3 }\n\t *\n\t * console.log(args.singleParse(parse));\n\t * // Err { error: null }\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @typeparam E The error type.\n\t * @param predicate The predicate that determines the parameter's transformed value, or nothing if failed.\n\t * @param useAnyways Whether to consider the parameter used even if the transformation failed. Defaults to `false`.\n\t * @returns The transformed value, if any.\n\t */\n\tpublic singleParse<T, E>(predicate: (value: string) => Result<T, E>, useAnyways = false): Result<T, E | null> {\n\t\tif (this.finished) return Result.err(null);\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tconst result = predicate(this.results.ordered[this.state.position].value);\n\t\tif (result.isOk() || useAnyways) {\n\t\t\tthis.state.used.add(this.state.position);\n\t\t\t++this.state.position;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Retrieves the value of the next unused ordered token, but only if it could be transformed.\n\t *\n\t * @note This is an asynchronous variant of {@link singleParse}.\n\t *\n\t * @typeparam T The output type.\n\t * @typeparam E The error type.\n\t * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.\n\t * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.\n\t * @returns The mapped value, if any.\n\t */\n\tpublic async singleParseAsync<T, E>(predicate: (value: string) => Promise<Result<T, E>>, useAnyways = false): Promise<Result<T, E | null>> {\n\t\tif (this.finished) return Result.err(null);\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tconst result = await predicate(this.results.ordered[this.state.position].value);\n\t\tif (result.isOk() || useAnyways) {\n\t\t\tthis.state.used.add(this.state.position);\n\t\t\t++this.state.position;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns the value of the first element in the array within `Option.some` where `predicate` returns `true`, and\n\t * `Option.none` otherwise.\n\t *\n\t * @note This does not support asynchronous results, refer to {@link findAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Suppose args are from 'ba aa cc'.\n\t *\n\t * console.log(args.find((value) => value.startsWith('a')));\n\t * // Some { value: 'aa' }\n\t * ```\n\t *\n\t * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it\n\t * finds one where `predicate` returns `true`. If such an element is found, find immediately returns a `Option.some`\n\t * with that element value. Otherwise, find returns `Option.none`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic find(predicate: (value: string) => boolean, from = this.state.position): Option<string> {\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tif (predicate(parameter)) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn Option.some(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn Option.none;\n\t}\n\n\t/**\n\t * Returns the value of the first element in the array within `Option.some` where `predicate` returns `true`, and\n\t * `Option.none` otherwise.\n\t *\n\t * @note This is an asynchronous variant of {@link find}.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Suppose args are from 'ba aa cc'.\n\t *\n\t * console.log(args.find((value) => value.startsWith('a')));\n\t * // Some { value: 'aa' }\n\t * ```\n\t *\n\t * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it\n\t * finds one where `predicate` returns `true`. If such an element is found, find immediately returns a `Option.some`\n\t * with that element value. Otherwise, find returns `Option.none`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic async findAsync(predicate: (value: string) => Promise<boolean>, from = this.state.position): Promise<Option<string>> {\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tif (await predicate(parameter)) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn Option.some(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn Option.none;\n\t}\n\n\t/**\n\t * Returns the value of the first element in the array within `Option.some` where `predicate` returns `Some`, and\n\t * `Option.none` otherwise.\n\t *\n\t * @note This does not support asynchronous results, refer to {@link findMapAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Suppose args are from 'ba aa cc'.\n\t *\n\t * console.log(args.find((value) => value.startsWith('a')));\n\t * // Some { value: 'aa' }\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it\n\t * finds one where `predicate` returns `Some`. If such an element is found, find immediately returns the returned\n\t * value. Otherwise, find returns `Option.none`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic findMap<T>(predicate: (value: string) => Option<T>, from = this.state.position): Option<T> {\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = predicate(parameter);\n\t\t\tif (result.isSome()) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn Option.none;\n\t}\n\n\t/**\n\t * Returns the value of the first element in the array within `Option.some` where `predicate` returns `Some`, and\n\t * `Option.none` otherwise.\n\t *\n\t * @note This is an asynchronous variant of {@link findMap}.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Suppose args are from 'ba aa cc'.\n\t *\n\t * console.log(args.find((value) => value.startsWith('a')));\n\t * // Some { value: 'aa' }\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it\n\t * finds one where `predicate` returns `Some`. If such an element is found, find immediately returns the returned\n\t * value. Otherwise, find returns `Option.none`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic async findMapAsync<T>(predicate: (value: string) => Promise<Option<T>>, from = this.state.position): Promise<Option<T>> {\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = await predicate(parameter);\n\t\t\tif (result.isSome()) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn Option.none;\n\t}\n\n\t/**\n\t * Finds and retrieves the first unused parameter that could be transformed.\n\t *\n\t * @note This is a variant of {@link findMap} that returns the errors on failure.\n\t * @note This does not support asynchronous results, refer to {@link findParseAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * const parse = (value) => {\n\t *   const number = Number(value);\n\t *   return Number.isNaN(number)\n\t *     ? Result.err(`Could not parse ${value} to a number`)\n\t *     : Result.ok(number);\n\t * };\n\t *\n\t * // Suppose args are from 'ba 1 cc'.\n\t *\n\t * console.log(args.findParse(parse));\n\t * // Ok { value: 1 }\n\t *\n\t * console.log(args.findParse(parse));\n\t * // Err {\n\t * //   error: [\n\t * //     'Could not parse ba to a number',\n\t * //     'Could not parse cc to a number'\n\t * //   ]\n\t * // }\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @typeparam E The error type.\n\t * @param predicate `findParse` calls `predicate` once for each unused ordered parameter, in ascending order, until\n\t * it finds one where `predicate` returns `Ok`. If such an element is found, `findParse` immediately returns the\n\t * returned value. Otherwise, `findParse` returns `Result.Err` with all the returned errors.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic findParse<T, E>(predicate: (value: string) => Result<T, E>, from = this.state.position): Result<T, E[]> {\n\t\tconst errors: E[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = predicate(parameter);\n\t\t\tif (result.isOk()) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn result as Result.Ok<T>;\n\t\t\t}\n\n\t\t\terrors.push(result.unwrapErr());\n\t\t}\n\n\t\treturn Result.err(errors);\n\t}\n\n\t/**\n\t * Finds and retrieves the first unused parameter that could be transformed.\n\t *\n\t * @note This is a variant of {@link findMapAsync} that returns the errors on failure.\n\t * @note This is an asynchronous variant of {@link findParse}.\n\t *\n\t * @typeparam T The output type.\n\t * @typeparam E The error type.\n\t * @param predicate `findParse` calls `predicate` once for each unused ordered parameter, in ascending order, until\n\t * it finds one where `predicate` returns `Ok`. If such an element is found, `findParse` immediately returns the\n\t * returned value. Otherwise, `findParse` returns `Result.Err` with all the returned errors.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic async findParseAsync<T, E>(predicate: (value: string) => Promise<Result<T, E>>, from = this.state.position): Promise<Result<T, E[]>> {\n\t\tconst errors: E[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = await predicate(parameter);\n\t\t\tif (result.isOk()) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn result as Result.Ok<T>;\n\t\t\t}\n\n\t\t\terrors.push(result.unwrapErr());\n\t\t}\n\n\t\treturn Result.err(errors);\n\t}\n\n\t/**\n\t * Retrieves multiple unused parameters.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(join(args.many().unwrap()));\n\t * // '1 2 3'\n\t * ```\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(join(args.many(2).unwrap()));\n\t * // '1 2'\n\t * ```\n\t *\n\t * @param limit The maximum amount of parameters to retrieve, defaults to `Infinity`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The unused parameters within the range.\n\t */\n\tpublic many(limit = Infinity, from = this.state.position): Option<Parameter[]> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: Parameter[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\t// If the current parameter was already used, skip:\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\t// Mark current parameter as used, and push it to the resulting array:\n\t\t\tthis.state.used.add(i);\n\t\t\tparameters.push(this.results.ordered[i]);\n\n\t\t\t// If the parameters reached the limit, break the loop:\n\t\t\tif (parameters.length >= limit) break;\n\t\t}\n\n\t\treturn parameters.length ? Option.some(parameters) : Option.none;\n\t}\n\n\tpublic filter(predicate: (value: string) => boolean, from = this.state.position): Option<string[]> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: string[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tif (predicate(parameter)) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\tparameters.push(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn Option.some(parameters);\n\t}\n\n\tpublic async filterAsync(predicate: (value: string) => Promise<boolean>, from = this.state.position): Promise<Option<string[]>> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: string[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tif (await predicate(parameter)) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\tparameters.push(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn Option.some(parameters);\n\t}\n\n\tpublic filterMap<T>(predicate: (value: string) => Option<T>, from = this.state.position): Option<T[]> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: T[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = predicate(parameter);\n\t\t\tresult.inspect((value) => {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\tparameters.push(value);\n\t\t\t});\n\t\t}\n\n\t\treturn Option.some(parameters);\n\t}\n\n\tpublic async filterMapAsync<T>(predicate: (value: string) => Promise<Option<T>>, from = this.state.position): Promise<Option<T[]>> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: T[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = await predicate(parameter);\n\t\t\tresult.inspect((value) => {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\tparameters.push(value);\n\t\t\t});\n\t\t}\n\n\t\treturn Option.some(parameters);\n\t}\n\n\t/**\n\t * Checks whether any of the flags were given.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '--f --g':\n\t *\n\t * console.log(args.flag('f'));\n\t * // true\n\t *\n\t * console.log(args.flag('g', 'h'));\n\t * // true\n\t *\n\t * console.log(args.flag('h'));\n\t * // false\n\t * ```\n\t *\n\t * @param keys The names of the flags to check.\n\t * @returns Whether or not any of the flags were given.\n\t */\n\tpublic flag(...keys: readonly string[]): boolean {\n\t\treturn keys.some((key) => this.results.flags.has(key));\n\t}\n\n\t/**\n\t * Gets the last value of any option. When there are multiple names, the last value of the last found name is given.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '--a=1 --b=2 --c=3'.\n\t * console.log(args.option('a'));\n\t * // Some { value: '1' }\n\t *\n\t * console.log(args.option('b', 'c'));\n\t * // Some { value: '3' }\n\t *\n\t * console.log(args.option('d'));\n\t * // None {}\n\t * ```\n\t *\n\t * @param keys The names of the options to check.\n\t * @returns The last value of the option, if any.\n\t */\n\tpublic option(...keys: readonly string[]): Option<string> {\n\t\treturn this.options(...keys).map((values) => values.at(-1)!);\n\t}\n\n\t/**\n\t * Gets all values from all options.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '--a=1 --a=1 --b=2 --c=3'.\n\t * console.log(args.option('a'));\n\t * // Some { value: ['1', '1'] }\n\t *\n\t * console.log(args.option('b', 'c'));\n\t * // Some { value: ['2', '3'] }\n\t *\n\t * console.log(args.option('d'));\n\t * // None {}\n\t * ```\n\t *\n\t * @param keys The names of the options to check.\n\t * @returns The values from all the options concatenated, if any.\n\t */\n\tpublic options(...keys: readonly string[]): Option<readonly string[]> {\n\t\tconst entries: string[] = [];\n\t\tfor (const key of keys) {\n\t\t\tconst values = this.results.options.get(key);\n\t\t\tif (values) entries.push(...values);\n\t\t}\n\n\t\treturn entries.length ? Option.some(entries) : Option.none;\n\t}\n\n\tpublic save(): ArgumentStream.State {\n\t\treturn {\n\t\t\tused: new Set(this.state.used),\n\t\t\tposition: this.state.position\n\t\t};\n\t}\n\n\tpublic restore(state: ArgumentStream.State) {\n\t\tthis.state = state;\n\t}\n\n\tpublic reset() {\n\t\tthis.restore({ used: new Set(), position: 0 });\n\t}\n}\n\nexport namespace ArgumentStream {\n\texport interface State {\n\t\tused: Set<number>;\n\t\tposition: number;\n\t}\n}\n","export abstract class BaseParameter {\n\tpublic readonly separators: readonly string[];\n\n\tpublic constructor(separators: readonly string[]) {\n\t\tthis.separators = separators;\n\t}\n\n\tpublic get leading(): string {\n\t\treturn this.separators.join('');\n\t}\n\n\tpublic abstract get raw(): string;\n}\n","import type { QuotedToken } from '../raw/TokenStream';\nimport { BaseParameter } from './BaseParameter';\n\nexport class QuotedParameter extends BaseParameter {\n\tpublic readonly value: string;\n\tpublic readonly open: string;\n\tpublic readonly close: string;\n\n\tpublic constructor(separators: readonly string[], part: Omit<QuotedToken, 'type'>) {\n\t\tsuper(separators);\n\t\tthis.value = part.value;\n\t\tthis.open = part.open;\n\t\tthis.close = part.close;\n\t}\n\n\tpublic get raw() {\n\t\treturn `${this.open}${this.value}${this.close}`;\n\t}\n}\n","import type { WordToken } from '../raw/TokenStream';\nimport { BaseParameter } from './BaseParameter';\n\nexport class WordParameter extends BaseParameter {\n\tpublic readonly value: string;\n\n\tpublic constructor(separators: readonly string[], part: Omit<WordToken, 'type'>) {\n\t\tsuper(separators);\n\t\tthis.value = part.value;\n\t}\n\n\tpublic get raw() {\n\t\treturn this.value;\n\t}\n}\n","import type { Lexer } from '../../Lexer';\n\nexport class TokenStream implements Iterable<Token> {\n\tprivate readonly input: string;\n\tprivate readonly quotes: readonly [string, string][];\n\tprivate readonly separator: string;\n\tprivate position = 0;\n\n\tpublic constructor(lexer: Lexer, input: string) {\n\t\tthis.quotes = lexer.quotes;\n\t\tthis.separator = lexer.separator;\n\t\tthis.input = input;\n\t}\n\n\tpublic get finished() {\n\t\treturn this.position >= this.input.length;\n\t}\n\n\tpublic *[Symbol.iterator](): Iterator<Token> {\n\t\twhile (!this.finished) {\n\t\t\tyield this.getPossibleSeparator() ?? this.getPossibleQuotedArgument() ?? this.getParameter();\n\t\t}\n\t}\n\n\tprivate getPossibleSeparator(): SeparatorToken | null {\n\t\tif (this.input.startsWith(this.separator, this.position)) {\n\t\t\tthis.position += this.separator.length;\n\t\t\treturn { type: TokenType.Separator, value: this.separator };\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate getPossibleQuotedArgument(): QuotedToken | null {\n\t\tfor (const [open, close] of this.quotes) {\n\t\t\tif (!this.input.startsWith(open, this.position)) continue;\n\n\t\t\tconst end = this.input.indexOf(close, this.position + open.length);\n\t\t\tif (end === -1) continue;\n\n\t\t\tconst value = this.input.slice(this.position + open.length, end);\n\t\t\tthis.position = end + close.length;\n\n\t\t\treturn { type: TokenType.Quoted, value, open, close };\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate getParameter(): WordToken {\n\t\tconst index = this.input.indexOf(this.separator, this.position);\n\t\tconst value = index === -1 ? this.input.slice(this.position) : this.input.slice(this.position, index);\n\t\tthis.position += value.length;\n\t\treturn { type: TokenType.Parameter, value };\n\t}\n}\n\nexport enum TokenType {\n\tParameter,\n\tQuoted,\n\tSeparator\n}\n\nexport type Token = WordToken | QuotedToken | SeparatorToken;\n\nexport interface WordToken {\n\treadonly type: TokenType.Parameter;\n\treadonly value: string;\n}\n\nexport interface QuotedToken {\n\treadonly type: TokenType.Quoted;\n\treadonly value: string;\n\treadonly open: string;\n\treadonly close: string;\n}\n\nexport interface SeparatorToken {\n\treadonly type: TokenType.Separator;\n\treadonly value: string;\n}\n","import { QuotedParameter } from './parameters/QuotedParameter';\nimport { WordParameter } from './parameters/WordParameter';\nimport { TokenType, type Token } from './raw/TokenStream';\n\nexport class ParameterStream {\n\tprivate readonly stream: Iterable<Token>;\n\tprivate separators: string[] = [];\n\n\tpublic constructor(stream: Iterable<Token>) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic *[Symbol.iterator](): Iterator<Parameter, string[]> {\n\t\tfor (const part of this.stream) {\n\t\t\tif (part.type === TokenType.Separator) {\n\t\t\t\tthis.separators.push(part.value);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tyield part.type === TokenType.Quoted ? new QuotedParameter(this.separators, part) : new WordParameter(this.separators, part);\n\t\t\tthis.separators = [];\n\t\t}\n\n\t\treturn this.separators;\n\t}\n}\n\nexport type Parameter = QuotedParameter | WordParameter;\n","import { ParameterStream } from './streams/ParameterStream';\nimport { TokenStream } from './streams/raw/TokenStream';\n\nexport class Lexer {\n\tpublic readonly quotes: readonly [open: string, close: string][];\n\tpublic readonly separator: string;\n\n\tpublic constructor(options: Lexer.Options = {}) {\n\t\tthis.quotes = options.quotes ?? [];\n\t\tthis.separator = options.separator ?? ' ';\n\t}\n\n\tpublic run(input: string) {\n\t\treturn new ParameterStream(this.raw(input));\n\t}\n\n\tpublic raw(input: string) {\n\t\treturn new TokenStream(this, input);\n\t}\n}\n\nexport namespace Lexer {\n\texport interface Options {\n\t\tseparator?: string;\n\t\tquotes?: readonly [open: string, close: string][];\n\t}\n}\n","import type { Parameter } from '../lexer/streams/ParameterStream';\nimport type { Parser } from './Parser';\nimport type { IUnorderedStrategy } from './strategies/IUnorderedStrategy';\n\nexport class ParserResult {\n\tpublic readonly ordered: Parameter[] = [];\n\tpublic readonly flags = new Set<string>();\n\tpublic readonly options = new Map<string, string[]>();\n\tprivate readonly strategy: IUnorderedStrategy;\n\n\tpublic constructor(parser: Parser) {\n\t\tthis.strategy = parser.strategy;\n\t}\n\n\tpublic parse(parameters: Iterable<Parameter>) {\n\t\tfor (const parameter of parameters) {\n\t\t\tthis.parsePossibleFlag(parameter) || this.parsePossibleOptions(parameter) || this.parseOrdered(parameter);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprivate parsePossibleFlag(parameter: Parameter): boolean {\n\t\treturn this.strategy\n\t\t\t.matchFlag(parameter.value)\n\t\t\t.inspect((value) => this.flags.add(value))\n\t\t\t.isSome();\n\t}\n\n\tprivate parsePossibleOptions(parameter: Parameter): boolean {\n\t\treturn this.strategy\n\t\t\t.matchOption(parameter.value)\n\t\t\t.inspect(([key, value]) => {\n\t\t\t\tconst existing = this.options.get(key);\n\t\t\t\tif (existing) existing.push(value);\n\t\t\t\telse this.options.set(key, [value]);\n\t\t\t})\n\t\t\t.isSome();\n\t}\n\n\tprivate parseOrdered(parameter: Parameter): boolean {\n\t\tthis.ordered.push(parameter);\n\t\treturn true;\n\t}\n}\n","import { Option } from '@sapphire/result';\nimport type { IUnorderedStrategy } from './IUnorderedStrategy';\n\nexport class EmptyStrategy implements IUnorderedStrategy {\n\tpublic matchFlag(): Option<string> {\n\t\treturn Option.none;\n\t}\n\n\tpublic matchOption(): Option<readonly [key: string, value: string]> {\n\t\treturn Option.none;\n\t}\n}\n","import type { Parameter } from '../lexer/streams/ParameterStream';\nimport type { IUnorderedStrategy } from './strategies/IUnorderedStrategy';\nimport { ParserResult } from './ParserResult';\nimport { EmptyStrategy } from './strategies/EmptyStrategy';\n\nexport class Parser {\n\tpublic strategy: IUnorderedStrategy;\n\n\tpublic constructor(strategy?: IUnorderedStrategy) {\n\t\tthis.strategy = strategy ?? new EmptyStrategy();\n\t}\n\n\tpublic setUnorderedStrategy(strategy: IUnorderedStrategy) {\n\t\tthis.strategy = strategy;\n\t\treturn this;\n\t}\n\n\tpublic run(input: Iterable<Parameter>): ParserResult {\n\t\treturn new ParserResult(this).parse(input);\n\t}\n}\n","import { Option } from '@sapphire/result';\nimport type { IUnorderedStrategy } from './IUnorderedStrategy';\n\nexport class PrefixedStrategy implements IUnorderedStrategy {\n\tpublic readonly prefixes: readonly string[];\n\tpublic readonly separators: readonly string[];\n\n\tpublic constructor(prefixes: readonly string[], separators: readonly string[]) {\n\t\tthis.prefixes = prefixes;\n\t\tthis.separators = separators;\n\t}\n\n\tpublic matchFlag(input: string): Option<string> {\n\t\tconst prefix = this.prefixes.find((x) => input.startsWith(x));\n\n\t\t// If the prefix is missing, return None:\n\t\tif (!prefix) return Option.none;\n\n\t\t// If the separator is present, return None:\n\t\tif (this.separators.some((x) => input.includes(x, prefix.length))) return Option.none;\n\n\t\treturn Option.some(input.slice(prefix.length));\n\t}\n\n\tpublic matchOption(input: string): Option<readonly [key: string, value: string]> {\n\t\tconst prefix = this.prefixes.find((x) => input.startsWith(x));\n\n\t\t// If the prefix is missing, return None:\n\t\tif (!prefix) return Option.none;\n\n\t\tfor (const separator of this.separators) {\n\t\t\tconst index = input.indexOf(separator, prefix.length + 1);\n\n\t\t\t// If the separator is missing, skip:\n\t\t\tif (index === -1) continue;\n\n\t\t\t// If the separator is present, but has no value, return None:\n\t\t\tif (index + separator.length === input.length) return Option.none;\n\n\t\t\tconst key = input.slice(prefix.length, index);\n\t\t\tconst value = input.slice(index + separator.length);\n\t\t\treturn Option.some([key, value] as const);\n\t\t}\n\n\t\treturn Option.none;\n\t}\n}\n","import type { Parameter } from '../lexer/streams/ParameterStream';\n\n/**\n * Joins the parameters by their `leading` value, using the `value` property.\n * @seealso {@link joinRaw} for the version using `raw` instead of `value`.\n * @param parameters The parameters to join.\n * @returns The result of joining the parameters.\n */\nexport function join(parameters: readonly Parameter[]) {\n\tif (parameters.length === 0) return '';\n\tif (parameters.length === 1) return parameters[0].value;\n\n\tlet output = parameters[0].value;\n\tfor (let i = 1; i < parameters.length; i++) {\n\t\tconst parameter = parameters[i];\n\t\toutput += parameter.leading + parameter.value;\n\t}\n\n\treturn output;\n}\n\n/**\n * Joins the parameters by their `leading` value, using the `raw` property.\n * @seealso {@link join} for the version using `value` instead of `raw`.\n * @param parameters The parameters to join.\n * @returns The result of joining the parameters.\n */\nexport function joinRaw(parameters: readonly Parameter[]) {\n\tif (parameters.length === 0) return '';\n\tif (parameters.length === 1) return parameters[0].raw;\n\n\tlet output = parameters[0].raw;\n\tfor (let i = 1; i < parameters.length; i++) {\n\t\tconst parameter = parameters[i];\n\t\toutput += parameter.leading + parameter.raw;\n\t}\n\n\treturn output;\n}\n"],"mappings":"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","names":["__name","__publicField","Option","Result","TokenType"]}