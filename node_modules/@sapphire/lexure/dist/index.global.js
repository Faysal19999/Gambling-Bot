"use strict";
var SapphireLexure = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    ArgumentStream: () => ArgumentStream,
    BaseParameter: () => BaseParameter,
    EmptyStrategy: () => EmptyStrategy,
    Lexer: () => Lexer,
    ParameterStream: () => ParameterStream,
    Parser: () => Parser,
    ParserResult: () => ParserResult,
    PrefixedStrategy: () => PrefixedStrategy,
    QuotedParameter: () => QuotedParameter,
    TokenStream: () => TokenStream,
    TokenType: () => TokenType,
    WordParameter: () => WordParameter,
    join: () => join,
    joinRaw: () => joinRaw
  });

  // ../result/dist/index.mjs
  var __defProp2 = Object.defineProperty;
  var __defNormalProp2 = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
  var __name2 = /* @__PURE__ */ __name((target, value) => __defProp2(target, "name", { value, configurable: true }), "__name");
  var __publicField2 = /* @__PURE__ */ __name((obj, key, value) => {
    __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  }, "__publicField");
  function isFunction(input) {
    return typeof input === "function";
  }
  __name(isFunction, "isFunction");
  __name2(isFunction, "isFunction");
  var ResultError = /* @__PURE__ */ __name(class extends Error {
    constructor(message, value) {
      super(message);
      __publicField2(this, "value");
      this.value = value;
    }
    get name() {
      return this.constructor.name;
    }
  }, "ResultError");
  __name2(ResultError, "ResultError");
  var Ok = /* @__PURE__ */ __name(class {
    constructor(value) {
      __publicField2(this, "value");
      this.value = value;
    }
    isOk() {
      return true;
    }
    isOkAnd(cb) {
      return cb(this.value);
    }
    isErr() {
      return false;
    }
    isErrAnd() {
      return false;
    }
    ok() {
      return some(this.value);
    }
    err() {
      return none;
    }
    map(cb) {
      return ok(cb(this.value));
    }
    mapInto(cb) {
      return cb(this.value);
    }
    mapOr(_, cb) {
      return cb(this.value);
    }
    mapOrElse(_, cb) {
      return cb(this.value);
    }
    mapErr() {
      return this;
    }
    mapErrInto() {
      return this;
    }
    inspect(cb) {
      cb(this.value);
      return this;
    }
    async inspectAsync(cb) {
      await cb(this.value);
      return this;
    }
    inspectErr() {
      return this;
    }
    inspectErrAsync() {
      return Promise.resolve(this);
    }
    *iter() {
      yield this.value;
    }
    expect() {
      return this.value;
    }
    expectErr(message) {
      throw new ResultError(message, this.value);
    }
    unwrap() {
      return this.value;
    }
    unwrapErr() {
      throw new ResultError("Unwrap failed", this.value);
    }
    unwrapOr() {
      return this.value;
    }
    unwrapOrElse() {
      return this.value;
    }
    and(result) {
      return result;
    }
    andThen(cb) {
      return cb(this.value);
    }
    or() {
      return this;
    }
    orElse() {
      return this;
    }
    contains(value) {
      return this.value === value;
    }
    containsErr() {
      return false;
    }
    transpose() {
      return this.value.match({
        some: (value) => some(ok(value)),
        none: () => none
      });
    }
    flatten() {
      return this.value;
    }
    intoOkOrErr() {
      return this.value;
    }
    async intoPromise() {
      return ok(await this.value);
    }
    eq(other) {
      return other.isOkAnd((value) => this.value === value);
    }
    ne(other) {
      return !this.eq(other);
    }
    match(branches) {
      return branches.ok(this.value);
    }
    *[Symbol.iterator]() {
      yield this.value;
    }
  }, "Ok");
  __name2(Ok, "Ok");
  function ok(x) {
    return new Ok(x);
  }
  __name(ok, "ok");
  __name2(ok, "ok");
  var Some = /* @__PURE__ */ __name(class {
    constructor(value) {
      __publicField2(this, "value");
      this.value = value;
    }
    isSome() {
      return true;
    }
    isSomeAnd(cb) {
      return cb(this.value);
    }
    isNone() {
      return false;
    }
    expect() {
      return this.value;
    }
    unwrap() {
      return this.value;
    }
    unwrapOr() {
      return this.value;
    }
    unwrapOrElse() {
      return this.value;
    }
    map(cb) {
      return some(cb(this.value));
    }
    mapInto(cb) {
      return cb(this.value);
    }
    mapOr(_, cb) {
      return cb(this.value);
    }
    mapOrElse(_, cb) {
      return cb(this.value);
    }
    mapNoneInto() {
      return this;
    }
    inspect(cb) {
      cb(this.value);
      return this;
    }
    async inspectAsync(cb) {
      await cb(this.value);
      return this;
    }
    okOr() {
      return ok(this.value);
    }
    okOrElse() {
      return ok(this.value);
    }
    *iter() {
      yield this.value;
    }
    and(option) {
      return option;
    }
    andThen(cb) {
      return cb(this.value);
    }
    or() {
      return this;
    }
    orElse() {
      return this;
    }
    xor(option) {
      return option.isSome() ? none : this;
    }
    filter(predicate) {
      return predicate(this.value) ? this : none;
    }
    contains(value) {
      return this.value === value;
    }
    zip(other) {
      return other.map((o) => [this.value, o]);
    }
    zipWith(other, f) {
      return other.map((o) => f(this.value, o));
    }
    unzip() {
      const [s, o] = this.value;
      return [some(s), some(o)];
    }
    transpose() {
      return this.value.match({
        ok: (v) => ok(some(v)),
        err: (e) => err(e)
      });
    }
    flatten() {
      return this.value;
    }
    async intoPromise() {
      return some(await this.value);
    }
    eq(other) {
      return other.isSomeAnd((value) => this.value === value);
    }
    ne(other) {
      return !this.eq(other);
    }
    match(branches) {
      return branches.some(this.value);
    }
    *[Symbol.iterator]() {
      yield this.value;
    }
  }, "Some");
  __name2(Some, "Some");
  function some(value) {
    return new Some(value);
  }
  __name(some, "some");
  __name2(some, "some");
  var Err = /* @__PURE__ */ __name(class {
    constructor(error) {
      __publicField2(this, "error");
      this.error = error;
    }
    isOk() {
      return false;
    }
    isOkAnd() {
      return false;
    }
    isErr() {
      return true;
    }
    isErrAnd(cb) {
      return cb(this.error);
    }
    ok() {
      return none;
    }
    err() {
      return some(this.error);
    }
    map() {
      return this;
    }
    mapInto() {
      return this;
    }
    mapOr(defaultValue) {
      return defaultValue;
    }
    mapOrElse(op) {
      return op(this.error);
    }
    mapErr(cb) {
      return err(cb(this.error));
    }
    mapErrInto(cb) {
      return cb(this.error);
    }
    inspect() {
      return this;
    }
    inspectAsync() {
      return Promise.resolve(this);
    }
    inspectErr(cb) {
      cb(this.error);
      return this;
    }
    async inspectErrAsync(cb) {
      await cb(this.error);
      return this;
    }
    *iter() {
    }
    expect(message) {
      throw new ResultError(message, this.error);
    }
    expectErr() {
      return this.error;
    }
    unwrap() {
      throw new ResultError("Unwrap failed", this.error);
    }
    unwrapErr() {
      return this.error;
    }
    unwrapOr(defaultValue) {
      return defaultValue;
    }
    unwrapOrElse(op) {
      return op(this.error);
    }
    and() {
      return this;
    }
    andThen() {
      return this;
    }
    or(result) {
      return result;
    }
    orElse(cb) {
      return cb(this.error);
    }
    contains() {
      return false;
    }
    containsErr(error) {
      return this.error === error;
    }
    transpose() {
      return some(this);
    }
    flatten() {
      return this;
    }
    intoOkOrErr() {
      return this.error;
    }
    async intoPromise() {
      return err(await this.error);
    }
    eq(other) {
      return other.isErrAnd((error) => this.error === error);
    }
    ne(other) {
      return !this.eq(other);
    }
    match(branches) {
      return branches.err(this.error);
    }
    *[Symbol.iterator]() {
    }
  }, "Err");
  __name2(Err, "Err");
  function err(x) {
    return new Err(x);
  }
  __name(err, "err");
  __name2(err, "err");
  var OptionError = /* @__PURE__ */ __name(class extends Error {
    get name() {
      return this.constructor.name;
    }
  }, "OptionError");
  __name2(OptionError, "OptionError");
  var None = /* @__PURE__ */ __name(class {
    isSome() {
      return false;
    }
    isSomeAnd() {
      return false;
    }
    isNone() {
      return true;
    }
    expect(message) {
      throw new OptionError(message);
    }
    unwrap() {
      throw new OptionError("Unwrap failed");
    }
    unwrapOr(defaultValue) {
      return defaultValue;
    }
    unwrapOrElse(cb) {
      return cb();
    }
    map() {
      return this;
    }
    mapInto() {
      return this;
    }
    mapOr(defaultValue) {
      return defaultValue;
    }
    mapOrElse(defaultValue) {
      return defaultValue();
    }
    mapNoneInto(cb) {
      return cb();
    }
    inspect() {
      return this;
    }
    inspectAsync() {
      return Promise.resolve(this);
    }
    okOr(error) {
      return err(error);
    }
    okOrElse(cb) {
      return err(cb());
    }
    *iter() {
    }
    and() {
      return this;
    }
    andThen() {
      return this;
    }
    or(option) {
      return option;
    }
    orElse(cb) {
      return cb();
    }
    xor(option) {
      return option.isSome() ? option : this;
    }
    filter() {
      return this;
    }
    contains() {
      return false;
    }
    zip() {
      return this;
    }
    zipWith() {
      return this;
    }
    unzip() {
      return [this, this];
    }
    transpose() {
      return ok(this);
    }
    flatten() {
      return this;
    }
    intoPromise() {
      return Promise.resolve(none);
    }
    eq(other) {
      return other.isNone();
    }
    ne(other) {
      return other.isSome();
    }
    match(branches) {
      return branches.none();
    }
    *[Symbol.iterator]() {
    }
  }, "None");
  __name2(None, "None");
  var none = new None();
  var Option;
  ((Option2) => {
    function resolve(value) {
      if (value === null || value === void 0)
        return Option2.none;
      if (is(value))
        return value;
      return Option2.some(value);
    }
    __name(resolve, "resolve");
    __name2(resolve, "resolve");
    function is(value) {
      return value instanceof None || value instanceof Some;
    }
    __name(is, "is");
    Option2.is = is;
    __name2(is, "is");
    function from(op) {
      if (!isFunction(op))
        return resolve(op);
      try {
        return resolve(op());
      } catch {
        return Option2.none;
      }
    }
    __name(from, "from");
    Option2.from = from;
    __name2(from, "from");
    async function fromAsync(op) {
      try {
        return resolve(await (isFunction(op) ? op() : op));
      } catch {
        return Option2.none;
      }
    }
    __name(fromAsync, "fromAsync");
    Option2.fromAsync = fromAsync;
    __name2(fromAsync, "fromAsync");
    Option2.none = none;
    Option2.some = some;
  })(Option || (Option = {}));
  var Result;
  ((Result2) => {
    function resolve(value) {
      if (is(value))
        return value;
      return Result2.ok(value);
    }
    __name(resolve, "resolve");
    __name2(resolve, "resolve");
    function is(value) {
      return value instanceof Ok || value instanceof Err;
    }
    __name(is, "is");
    Result2.is = is;
    __name2(is, "is");
    function from(op) {
      if (!isFunction(op))
        return resolve(op);
      try {
        return resolve(op());
      } catch (error) {
        return Result2.err(error);
      }
    }
    __name(from, "from");
    Result2.from = from;
    __name2(from, "from");
    async function fromAsync(op) {
      try {
        return resolve(await (isFunction(op) ? op() : op));
      } catch (error) {
        return Result2.err(error);
      }
    }
    __name(fromAsync, "fromAsync");
    Result2.fromAsync = fromAsync;
    __name2(fromAsync, "fromAsync");
    Result2.err = err;
    Result2.ok = ok;
  })(Result || (Result = {}));

  // src/lib/ArgumentStream.ts
  var ArgumentStream = class {
    constructor(results) {
      __publicField(this, "results");
      __publicField(this, "state");
      this.results = results;
      this.state = { used: /* @__PURE__ */ new Set(), position: 0 };
    }
    get finished() {
      return this.used === this.length;
    }
    get length() {
      return this.results.ordered.length;
    }
    get remaining() {
      return this.length - this.used;
    }
    get used() {
      return this.state.used.size;
    }
    single() {
      if (this.finished)
        return Option.none;
      while (this.state.used.has(this.state.position)) {
        ++this.state.position;
      }
      this.state.used.add(this.state.position);
      return Option.some(this.results.ordered[this.state.position++].value);
    }
    singleMap(predicate, useAnyways = false) {
      if (this.finished)
        return Option.none;
      while (this.state.used.has(this.state.position)) {
        ++this.state.position;
      }
      const result = predicate(this.results.ordered[this.state.position].value);
      if (result.isSome() || useAnyways) {
        this.state.used.add(this.state.position);
        ++this.state.position;
      }
      return result;
    }
    async singleMapAsync(predicate, useAnyways = false) {
      if (this.finished)
        return Option.none;
      while (this.state.used.has(this.state.position)) {
        ++this.state.position;
      }
      const result = await predicate(this.results.ordered[this.state.position].value);
      if (result.isSome() || useAnyways) {
        this.state.used.add(this.state.position);
        ++this.state.position;
      }
      return result;
    }
    singleParse(predicate, useAnyways = false) {
      if (this.finished)
        return Result.err(null);
      while (this.state.used.has(this.state.position)) {
        ++this.state.position;
      }
      const result = predicate(this.results.ordered[this.state.position].value);
      if (result.isOk() || useAnyways) {
        this.state.used.add(this.state.position);
        ++this.state.position;
      }
      return result;
    }
    async singleParseAsync(predicate, useAnyways = false) {
      if (this.finished)
        return Result.err(null);
      while (this.state.used.has(this.state.position)) {
        ++this.state.position;
      }
      const result = await predicate(this.results.ordered[this.state.position].value);
      if (result.isOk() || useAnyways) {
        this.state.used.add(this.state.position);
        ++this.state.position;
      }
      return result;
    }
    find(predicate, from = this.state.position) {
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        if (predicate(parameter)) {
          this.state.used.add(i);
          return Option.some(parameter);
        }
      }
      return Option.none;
    }
    async findAsync(predicate, from = this.state.position) {
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        if (await predicate(parameter)) {
          this.state.used.add(i);
          return Option.some(parameter);
        }
      }
      return Option.none;
    }
    findMap(predicate, from = this.state.position) {
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        const result = predicate(parameter);
        if (result.isSome()) {
          this.state.used.add(i);
          return result;
        }
      }
      return Option.none;
    }
    async findMapAsync(predicate, from = this.state.position) {
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        const result = await predicate(parameter);
        if (result.isSome()) {
          this.state.used.add(i);
          return result;
        }
      }
      return Option.none;
    }
    findParse(predicate, from = this.state.position) {
      const errors = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        const result = predicate(parameter);
        if (result.isOk()) {
          this.state.used.add(i);
          return result;
        }
        errors.push(result.unwrapErr());
      }
      return Result.err(errors);
    }
    async findParseAsync(predicate, from = this.state.position) {
      const errors = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        const result = await predicate(parameter);
        if (result.isOk()) {
          this.state.used.add(i);
          return result;
        }
        errors.push(result.unwrapErr());
      }
      return Result.err(errors);
    }
    many(limit = Infinity, from = this.state.position) {
      if (this.finished)
        return Option.none;
      const parameters = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        this.state.used.add(i);
        parameters.push(this.results.ordered[i]);
        if (parameters.length >= limit)
          break;
      }
      return parameters.length ? Option.some(parameters) : Option.none;
    }
    filter(predicate, from = this.state.position) {
      if (this.finished)
        return Option.none;
      const parameters = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        if (predicate(parameter)) {
          this.state.used.add(i);
          parameters.push(parameter);
        }
      }
      return Option.some(parameters);
    }
    async filterAsync(predicate, from = this.state.position) {
      if (this.finished)
        return Option.none;
      const parameters = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        if (await predicate(parameter)) {
          this.state.used.add(i);
          parameters.push(parameter);
        }
      }
      return Option.some(parameters);
    }
    filterMap(predicate, from = this.state.position) {
      if (this.finished)
        return Option.none;
      const parameters = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        const result = predicate(parameter);
        result.inspect((value) => {
          this.state.used.add(i);
          parameters.push(value);
        });
      }
      return Option.some(parameters);
    }
    async filterMapAsync(predicate, from = this.state.position) {
      if (this.finished)
        return Option.none;
      const parameters = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i))
          continue;
        const parameter = this.results.ordered[i].value;
        const result = await predicate(parameter);
        result.inspect((value) => {
          this.state.used.add(i);
          parameters.push(value);
        });
      }
      return Option.some(parameters);
    }
    flag(...keys) {
      return keys.some((key) => this.results.flags.has(key));
    }
    option(...keys) {
      return this.options(...keys).map((values) => values.at(-1));
    }
    options(...keys) {
      const entries = [];
      for (const key of keys) {
        const values = this.results.options.get(key);
        if (values)
          entries.push(...values);
      }
      return entries.length ? Option.some(entries) : Option.none;
    }
    save() {
      return {
        used: new Set(this.state.used),
        position: this.state.position
      };
    }
    restore(state) {
      this.state = state;
    }
    reset() {
      this.restore({ used: /* @__PURE__ */ new Set(), position: 0 });
    }
  };
  __name(ArgumentStream, "ArgumentStream");

  // src/lib/lexer/streams/parameters/BaseParameter.ts
  var BaseParameter = class {
    constructor(separators) {
      __publicField(this, "separators");
      this.separators = separators;
    }
    get leading() {
      return this.separators.join("");
    }
  };
  __name(BaseParameter, "BaseParameter");

  // src/lib/lexer/streams/parameters/QuotedParameter.ts
  var QuotedParameter = class extends BaseParameter {
    constructor(separators, part) {
      super(separators);
      __publicField(this, "value");
      __publicField(this, "open");
      __publicField(this, "close");
      this.value = part.value;
      this.open = part.open;
      this.close = part.close;
    }
    get raw() {
      return `${this.open}${this.value}${this.close}`;
    }
  };
  __name(QuotedParameter, "QuotedParameter");

  // src/lib/lexer/streams/parameters/WordParameter.ts
  var WordParameter = class extends BaseParameter {
    constructor(separators, part) {
      super(separators);
      __publicField(this, "value");
      this.value = part.value;
    }
    get raw() {
      return this.value;
    }
  };
  __name(WordParameter, "WordParameter");

  // src/lib/lexer/streams/raw/TokenStream.ts
  var TokenStream = class {
    constructor(lexer, input) {
      __publicField(this, "input");
      __publicField(this, "quotes");
      __publicField(this, "separator");
      __publicField(this, "position", 0);
      this.quotes = lexer.quotes;
      this.separator = lexer.separator;
      this.input = input;
    }
    get finished() {
      return this.position >= this.input.length;
    }
    *[Symbol.iterator]() {
      while (!this.finished) {
        yield this.getPossibleSeparator() ?? this.getPossibleQuotedArgument() ?? this.getParameter();
      }
    }
    getPossibleSeparator() {
      if (this.input.startsWith(this.separator, this.position)) {
        this.position += this.separator.length;
        return { type: TokenType.Separator, value: this.separator };
      }
      return null;
    }
    getPossibleQuotedArgument() {
      for (const [open, close] of this.quotes) {
        if (!this.input.startsWith(open, this.position))
          continue;
        const end = this.input.indexOf(close, this.position + open.length);
        if (end === -1)
          continue;
        const value = this.input.slice(this.position + open.length, end);
        this.position = end + close.length;
        return { type: TokenType.Quoted, value, open, close };
      }
      return null;
    }
    getParameter() {
      const index = this.input.indexOf(this.separator, this.position);
      const value = index === -1 ? this.input.slice(this.position) : this.input.slice(this.position, index);
      this.position += value.length;
      return { type: TokenType.Parameter, value };
    }
  };
  __name(TokenStream, "TokenStream");
  var TokenType = /* @__PURE__ */ ((TokenType2) => {
    TokenType2[TokenType2["Parameter"] = 0] = "Parameter";
    TokenType2[TokenType2["Quoted"] = 1] = "Quoted";
    TokenType2[TokenType2["Separator"] = 2] = "Separator";
    return TokenType2;
  })(TokenType || {});

  // src/lib/lexer/streams/ParameterStream.ts
  var ParameterStream = class {
    constructor(stream) {
      __publicField(this, "stream");
      __publicField(this, "separators", []);
      this.stream = stream;
    }
    *[Symbol.iterator]() {
      for (const part of this.stream) {
        if (part.type === 2 /* Separator */) {
          this.separators.push(part.value);
          continue;
        }
        yield part.type === 1 /* Quoted */ ? new QuotedParameter(this.separators, part) : new WordParameter(this.separators, part);
        this.separators = [];
      }
      return this.separators;
    }
  };
  __name(ParameterStream, "ParameterStream");

  // src/lib/lexer/Lexer.ts
  var Lexer = class {
    constructor(options = {}) {
      __publicField(this, "quotes");
      __publicField(this, "separator");
      this.quotes = options.quotes ?? [];
      this.separator = options.separator ?? " ";
    }
    run(input) {
      return new ParameterStream(this.raw(input));
    }
    raw(input) {
      return new TokenStream(this, input);
    }
  };
  __name(Lexer, "Lexer");

  // src/lib/parser/ParserResult.ts
  var ParserResult = class {
    constructor(parser) {
      __publicField(this, "ordered", []);
      __publicField(this, "flags", /* @__PURE__ */ new Set());
      __publicField(this, "options", /* @__PURE__ */ new Map());
      __publicField(this, "strategy");
      this.strategy = parser.strategy;
    }
    parse(parameters) {
      for (const parameter of parameters) {
        this.parsePossibleFlag(parameter) || this.parsePossibleOptions(parameter) || this.parseOrdered(parameter);
      }
      return this;
    }
    parsePossibleFlag(parameter) {
      return this.strategy.matchFlag(parameter.value).inspect((value) => this.flags.add(value)).isSome();
    }
    parsePossibleOptions(parameter) {
      return this.strategy.matchOption(parameter.value).inspect(([key, value]) => {
        const existing = this.options.get(key);
        if (existing)
          existing.push(value);
        else
          this.options.set(key, [value]);
      }).isSome();
    }
    parseOrdered(parameter) {
      this.ordered.push(parameter);
      return true;
    }
  };
  __name(ParserResult, "ParserResult");

  // src/lib/parser/strategies/EmptyStrategy.ts
  var EmptyStrategy = class {
    matchFlag() {
      return Option.none;
    }
    matchOption() {
      return Option.none;
    }
  };
  __name(EmptyStrategy, "EmptyStrategy");

  // src/lib/parser/Parser.ts
  var Parser = class {
    constructor(strategy) {
      __publicField(this, "strategy");
      this.strategy = strategy ?? new EmptyStrategy();
    }
    setUnorderedStrategy(strategy) {
      this.strategy = strategy;
      return this;
    }
    run(input) {
      return new ParserResult(this).parse(input);
    }
  };
  __name(Parser, "Parser");

  // src/lib/parser/strategies/PrefixedStrategy.ts
  var PrefixedStrategy = class {
    constructor(prefixes, separators) {
      __publicField(this, "prefixes");
      __publicField(this, "separators");
      this.prefixes = prefixes;
      this.separators = separators;
    }
    matchFlag(input) {
      const prefix = this.prefixes.find((x) => input.startsWith(x));
      if (!prefix)
        return Option.none;
      if (this.separators.some((x) => input.includes(x, prefix.length)))
        return Option.none;
      return Option.some(input.slice(prefix.length));
    }
    matchOption(input) {
      const prefix = this.prefixes.find((x) => input.startsWith(x));
      if (!prefix)
        return Option.none;
      for (const separator of this.separators) {
        const index = input.indexOf(separator, prefix.length + 1);
        if (index === -1)
          continue;
        if (index + separator.length === input.length)
          return Option.none;
        const key = input.slice(prefix.length, index);
        const value = input.slice(index + separator.length);
        return Option.some([key, value]);
      }
      return Option.none;
    }
  };
  __name(PrefixedStrategy, "PrefixedStrategy");

  // src/lib/util/util.ts
  function join(parameters) {
    if (parameters.length === 0)
      return "";
    if (parameters.length === 1)
      return parameters[0].value;
    let output = parameters[0].value;
    for (let i = 1; i < parameters.length; i++) {
      const parameter = parameters[i];
      output += parameter.leading + parameter.value;
    }
    return output;
  }
  __name(join, "join");
  function joinRaw(parameters) {
    if (parameters.length === 0)
      return "";
    if (parameters.length === 1)
      return parameters[0].raw;
    let output = parameters[0].raw;
    for (let i = 1; i < parameters.length; i++) {
      const parameter = parameters[i];
      output += parameter.leading + parameter.raw;
    }
    return output;
  }
  __name(joinRaw, "joinRaw");
  return __toCommonJS(src_exports);
})();
//# sourceMappingURL=index.global.js.map