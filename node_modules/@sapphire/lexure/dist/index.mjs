var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/lib/ArgumentStream.ts
import { Option, Result } from "@sapphire/result";
var ArgumentStream = class {
  constructor(results) {
    __publicField(this, "results");
    __publicField(this, "state");
    this.results = results;
    this.state = { used: /* @__PURE__ */ new Set(), position: 0 };
  }
  get finished() {
    return this.used === this.length;
  }
  get length() {
    return this.results.ordered.length;
  }
  get remaining() {
    return this.length - this.used;
  }
  get used() {
    return this.state.used.size;
  }
  single() {
    if (this.finished)
      return Option.none;
    while (this.state.used.has(this.state.position)) {
      ++this.state.position;
    }
    this.state.used.add(this.state.position);
    return Option.some(this.results.ordered[this.state.position++].value);
  }
  singleMap(predicate, useAnyways = false) {
    if (this.finished)
      return Option.none;
    while (this.state.used.has(this.state.position)) {
      ++this.state.position;
    }
    const result = predicate(this.results.ordered[this.state.position].value);
    if (result.isSome() || useAnyways) {
      this.state.used.add(this.state.position);
      ++this.state.position;
    }
    return result;
  }
  async singleMapAsync(predicate, useAnyways = false) {
    if (this.finished)
      return Option.none;
    while (this.state.used.has(this.state.position)) {
      ++this.state.position;
    }
    const result = await predicate(this.results.ordered[this.state.position].value);
    if (result.isSome() || useAnyways) {
      this.state.used.add(this.state.position);
      ++this.state.position;
    }
    return result;
  }
  singleParse(predicate, useAnyways = false) {
    if (this.finished)
      return Result.err(null);
    while (this.state.used.has(this.state.position)) {
      ++this.state.position;
    }
    const result = predicate(this.results.ordered[this.state.position].value);
    if (result.isOk() || useAnyways) {
      this.state.used.add(this.state.position);
      ++this.state.position;
    }
    return result;
  }
  async singleParseAsync(predicate, useAnyways = false) {
    if (this.finished)
      return Result.err(null);
    while (this.state.used.has(this.state.position)) {
      ++this.state.position;
    }
    const result = await predicate(this.results.ordered[this.state.position].value);
    if (result.isOk() || useAnyways) {
      this.state.used.add(this.state.position);
      ++this.state.position;
    }
    return result;
  }
  find(predicate, from = this.state.position) {
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      if (predicate(parameter)) {
        this.state.used.add(i);
        return Option.some(parameter);
      }
    }
    return Option.none;
  }
  async findAsync(predicate, from = this.state.position) {
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      if (await predicate(parameter)) {
        this.state.used.add(i);
        return Option.some(parameter);
      }
    }
    return Option.none;
  }
  findMap(predicate, from = this.state.position) {
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      const result = predicate(parameter);
      if (result.isSome()) {
        this.state.used.add(i);
        return result;
      }
    }
    return Option.none;
  }
  async findMapAsync(predicate, from = this.state.position) {
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      const result = await predicate(parameter);
      if (result.isSome()) {
        this.state.used.add(i);
        return result;
      }
    }
    return Option.none;
  }
  findParse(predicate, from = this.state.position) {
    const errors = [];
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      const result = predicate(parameter);
      if (result.isOk()) {
        this.state.used.add(i);
        return result;
      }
      errors.push(result.unwrapErr());
    }
    return Result.err(errors);
  }
  async findParseAsync(predicate, from = this.state.position) {
    const errors = [];
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      const result = await predicate(parameter);
      if (result.isOk()) {
        this.state.used.add(i);
        return result;
      }
      errors.push(result.unwrapErr());
    }
    return Result.err(errors);
  }
  many(limit = Infinity, from = this.state.position) {
    if (this.finished)
      return Option.none;
    const parameters = [];
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      this.state.used.add(i);
      parameters.push(this.results.ordered[i]);
      if (parameters.length >= limit)
        break;
    }
    return parameters.length ? Option.some(parameters) : Option.none;
  }
  filter(predicate, from = this.state.position) {
    if (this.finished)
      return Option.none;
    const parameters = [];
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      if (predicate(parameter)) {
        this.state.used.add(i);
        parameters.push(parameter);
      }
    }
    return Option.some(parameters);
  }
  async filterAsync(predicate, from = this.state.position) {
    if (this.finished)
      return Option.none;
    const parameters = [];
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      if (await predicate(parameter)) {
        this.state.used.add(i);
        parameters.push(parameter);
      }
    }
    return Option.some(parameters);
  }
  filterMap(predicate, from = this.state.position) {
    if (this.finished)
      return Option.none;
    const parameters = [];
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      const result = predicate(parameter);
      result.inspect((value) => {
        this.state.used.add(i);
        parameters.push(value);
      });
    }
    return Option.some(parameters);
  }
  async filterMapAsync(predicate, from = this.state.position) {
    if (this.finished)
      return Option.none;
    const parameters = [];
    for (let i = from; i < this.length; ++i) {
      if (this.state.used.has(i))
        continue;
      const parameter = this.results.ordered[i].value;
      const result = await predicate(parameter);
      result.inspect((value) => {
        this.state.used.add(i);
        parameters.push(value);
      });
    }
    return Option.some(parameters);
  }
  flag(...keys) {
    return keys.some((key) => this.results.flags.has(key));
  }
  option(...keys) {
    return this.options(...keys).map((values) => values.at(-1));
  }
  options(...keys) {
    const entries = [];
    for (const key of keys) {
      const values = this.results.options.get(key);
      if (values)
        entries.push(...values);
    }
    return entries.length ? Option.some(entries) : Option.none;
  }
  save() {
    return {
      used: new Set(this.state.used),
      position: this.state.position
    };
  }
  restore(state) {
    this.state = state;
  }
  reset() {
    this.restore({ used: /* @__PURE__ */ new Set(), position: 0 });
  }
};
__name(ArgumentStream, "ArgumentStream");

// src/lib/lexer/streams/parameters/BaseParameter.ts
var BaseParameter = class {
  constructor(separators) {
    __publicField(this, "separators");
    this.separators = separators;
  }
  get leading() {
    return this.separators.join("");
  }
};
__name(BaseParameter, "BaseParameter");

// src/lib/lexer/streams/parameters/QuotedParameter.ts
var QuotedParameter = class extends BaseParameter {
  constructor(separators, part) {
    super(separators);
    __publicField(this, "value");
    __publicField(this, "open");
    __publicField(this, "close");
    this.value = part.value;
    this.open = part.open;
    this.close = part.close;
  }
  get raw() {
    return `${this.open}${this.value}${this.close}`;
  }
};
__name(QuotedParameter, "QuotedParameter");

// src/lib/lexer/streams/parameters/WordParameter.ts
var WordParameter = class extends BaseParameter {
  constructor(separators, part) {
    super(separators);
    __publicField(this, "value");
    this.value = part.value;
  }
  get raw() {
    return this.value;
  }
};
__name(WordParameter, "WordParameter");

// src/lib/lexer/streams/raw/TokenStream.ts
var TokenStream = class {
  constructor(lexer, input) {
    __publicField(this, "input");
    __publicField(this, "quotes");
    __publicField(this, "separator");
    __publicField(this, "position", 0);
    this.quotes = lexer.quotes;
    this.separator = lexer.separator;
    this.input = input;
  }
  get finished() {
    return this.position >= this.input.length;
  }
  *[Symbol.iterator]() {
    while (!this.finished) {
      yield this.getPossibleSeparator() ?? this.getPossibleQuotedArgument() ?? this.getParameter();
    }
  }
  getPossibleSeparator() {
    if (this.input.startsWith(this.separator, this.position)) {
      this.position += this.separator.length;
      return { type: TokenType.Separator, value: this.separator };
    }
    return null;
  }
  getPossibleQuotedArgument() {
    for (const [open, close] of this.quotes) {
      if (!this.input.startsWith(open, this.position))
        continue;
      const end = this.input.indexOf(close, this.position + open.length);
      if (end === -1)
        continue;
      const value = this.input.slice(this.position + open.length, end);
      this.position = end + close.length;
      return { type: TokenType.Quoted, value, open, close };
    }
    return null;
  }
  getParameter() {
    const index = this.input.indexOf(this.separator, this.position);
    const value = index === -1 ? this.input.slice(this.position) : this.input.slice(this.position, index);
    this.position += value.length;
    return { type: TokenType.Parameter, value };
  }
};
__name(TokenStream, "TokenStream");
var TokenType = /* @__PURE__ */ ((TokenType2) => {
  TokenType2[TokenType2["Parameter"] = 0] = "Parameter";
  TokenType2[TokenType2["Quoted"] = 1] = "Quoted";
  TokenType2[TokenType2["Separator"] = 2] = "Separator";
  return TokenType2;
})(TokenType || {});

// src/lib/lexer/streams/ParameterStream.ts
var ParameterStream = class {
  constructor(stream) {
    __publicField(this, "stream");
    __publicField(this, "separators", []);
    this.stream = stream;
  }
  *[Symbol.iterator]() {
    for (const part of this.stream) {
      if (part.type === 2 /* Separator */) {
        this.separators.push(part.value);
        continue;
      }
      yield part.type === 1 /* Quoted */ ? new QuotedParameter(this.separators, part) : new WordParameter(this.separators, part);
      this.separators = [];
    }
    return this.separators;
  }
};
__name(ParameterStream, "ParameterStream");

// src/lib/lexer/Lexer.ts
var Lexer = class {
  constructor(options = {}) {
    __publicField(this, "quotes");
    __publicField(this, "separator");
    this.quotes = options.quotes ?? [];
    this.separator = options.separator ?? " ";
  }
  run(input) {
    return new ParameterStream(this.raw(input));
  }
  raw(input) {
    return new TokenStream(this, input);
  }
};
__name(Lexer, "Lexer");

// src/lib/parser/ParserResult.ts
var ParserResult = class {
  constructor(parser) {
    __publicField(this, "ordered", []);
    __publicField(this, "flags", /* @__PURE__ */ new Set());
    __publicField(this, "options", /* @__PURE__ */ new Map());
    __publicField(this, "strategy");
    this.strategy = parser.strategy;
  }
  parse(parameters) {
    for (const parameter of parameters) {
      this.parsePossibleFlag(parameter) || this.parsePossibleOptions(parameter) || this.parseOrdered(parameter);
    }
    return this;
  }
  parsePossibleFlag(parameter) {
    return this.strategy.matchFlag(parameter.value).inspect((value) => this.flags.add(value)).isSome();
  }
  parsePossibleOptions(parameter) {
    return this.strategy.matchOption(parameter.value).inspect(([key, value]) => {
      const existing = this.options.get(key);
      if (existing)
        existing.push(value);
      else
        this.options.set(key, [value]);
    }).isSome();
  }
  parseOrdered(parameter) {
    this.ordered.push(parameter);
    return true;
  }
};
__name(ParserResult, "ParserResult");

// src/lib/parser/strategies/EmptyStrategy.ts
import { Option as Option2 } from "@sapphire/result";
var EmptyStrategy = class {
  matchFlag() {
    return Option2.none;
  }
  matchOption() {
    return Option2.none;
  }
};
__name(EmptyStrategy, "EmptyStrategy");

// src/lib/parser/Parser.ts
var Parser = class {
  constructor(strategy) {
    __publicField(this, "strategy");
    this.strategy = strategy ?? new EmptyStrategy();
  }
  setUnorderedStrategy(strategy) {
    this.strategy = strategy;
    return this;
  }
  run(input) {
    return new ParserResult(this).parse(input);
  }
};
__name(Parser, "Parser");

// src/lib/parser/strategies/PrefixedStrategy.ts
import { Option as Option3 } from "@sapphire/result";
var PrefixedStrategy = class {
  constructor(prefixes, separators) {
    __publicField(this, "prefixes");
    __publicField(this, "separators");
    this.prefixes = prefixes;
    this.separators = separators;
  }
  matchFlag(input) {
    const prefix = this.prefixes.find((x) => input.startsWith(x));
    if (!prefix)
      return Option3.none;
    if (this.separators.some((x) => input.includes(x, prefix.length)))
      return Option3.none;
    return Option3.some(input.slice(prefix.length));
  }
  matchOption(input) {
    const prefix = this.prefixes.find((x) => input.startsWith(x));
    if (!prefix)
      return Option3.none;
    for (const separator of this.separators) {
      const index = input.indexOf(separator, prefix.length + 1);
      if (index === -1)
        continue;
      if (index + separator.length === input.length)
        return Option3.none;
      const key = input.slice(prefix.length, index);
      const value = input.slice(index + separator.length);
      return Option3.some([key, value]);
    }
    return Option3.none;
  }
};
__name(PrefixedStrategy, "PrefixedStrategy");

// src/lib/util/util.ts
function join(parameters) {
  if (parameters.length === 0)
    return "";
  if (parameters.length === 1)
    return parameters[0].value;
  let output = parameters[0].value;
  for (let i = 1; i < parameters.length; i++) {
    const parameter = parameters[i];
    output += parameter.leading + parameter.value;
  }
  return output;
}
__name(join, "join");
function joinRaw(parameters) {
  if (parameters.length === 0)
    return "";
  if (parameters.length === 1)
    return parameters[0].raw;
  let output = parameters[0].raw;
  for (let i = 1; i < parameters.length; i++) {
    const parameter = parameters[i];
    output += parameter.leading + parameter.raw;
  }
  return output;
}
__name(joinRaw, "joinRaw");
export {
  ArgumentStream,
  BaseParameter,
  EmptyStrategy,
  Lexer,
  ParameterStream,
  Parser,
  ParserResult,
  PrefixedStrategy,
  QuotedParameter,
  TokenStream,
  TokenType,
  WordParameter,
  join,
  joinRaw
};
//# sourceMappingURL=index.mjs.map